FILE: ObjectManager.cs
using System;
using System.Collections.Generic;
using TaleWorlds.Core;
using TaleWorlds.Localization;

namespace Bannerlord.GameMaster
{
    /// <summary>
    /// Singleton manager for generating unique identifiers for game objects
    /// </summary>
    public class ObjectManager
    {
        private static readonly Lazy<ObjectManager> _instance = new(() => new());
        private List<string> objectStringIds;

        public static ObjectManager Instance => _instance.Value;

        // Private constructor to prevent external instantiation
        private ObjectManager()
        {
            objectStringIds = new();
        }

        /// <summary>
        /// Makes objects created with blgm easily identifiable by adding blgm_ prefix and adding to object list
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private string RegisterObject(string input)
        {
            input = $"blgm_{input}";
            objectStringIds.Add(input);

            return input;
        }

        private string CreateUniqueIdentifier()
        {
            return Guid.NewGuid().ToString("N");
        }

        private string CleanString(string stringToClean)
        {
            if (stringToClean != null && !stringToClean.IsEmpty())
                stringToClean = stringToClean.Trim().Replace(' ', '_');
            
            return stringToClean.ToLower();
        }

        public string[] GetObjectIds()
        {
            return objectStringIds.ToArray();
        }

        /// <summary>
        /// Return a unique string to use as a stringID for objects
        /// </summary>
        public string GetUniqueStringId()
        {
            string stringID = $"object_{CreateUniqueIdentifier()}";

            return RegisterObject(stringID);
        }

        /// <summary>
        /// Return a unique string to use as a stringID for objects prefixed with the objects type
        /// </summary>
        public string GetUniqueStringId(Type type)
        {
            string typeName = CleanString(type.Name);
            string stringID = $"{typeName}_{CreateUniqueIdentifier()}";

            return RegisterObject(stringID);
        }

        /// <summary>
        /// Return a unique string containing the provided name to use as a stringID for objects
        /// </summary>
        public string GetUniqueStringId(TextObject nameObj)
        {
            string name = CleanString(nameObj.ToString());
            string stringID = $"object_{name}_{CreateUniqueIdentifier()}";

            return RegisterObject(stringID);
        }

        /// <summary>
        /// Return a unique string containing the provided name and prefixed with the objects type to use as a stringID for objects
        /// </summary>
        public string GetUniqueStringId(TextObject nameObj, Type type)
        {
            string typeName = CleanString(type.Name);
            string name = CleanString(nameObj.ToString());

            string stringID = $"{typeName}_{name}_{CreateUniqueIdentifier()}";


            return RegisterObject(stringID);
        }
    }
}
FILE: RandomNumberGen.cs
using System;
using TaleWorlds.Core;

namespace Bannerlord.GameMaster
{
    /// <summary>
    /// Singleton Wrapper for System.Random, ensuring the same Random instance is used to prevent issues of constantly instantiating new Random
    /// </summary>
    public class RandomNumberGen
    {
        private static readonly Lazy<RandomNumberGen> _instance = new(() => new());
        public static RandomNumberGen Instance => _instance.Value;

        Random random;

        public RandomNumberGen()
        {
            random = new(Environment.TickCount);
        }

        /// <summary>Returns a non-negative random integer.</summary>
        public int NextRandomInt() => random.Next();      

        /// <summary>Returns a non-negative random integer that is less, but not equal to the specified maximum.</summary>
        public int NextRandomInt(int max) => random.Next(max);

        /// <summary>Returns a signed integer greater than or equal to min Value and less than max Value</summary>  
        public int NextRandomInt(int min, int max) => random.Next(min, max);

        /// <summary>A floating point number that is greater than or equal to 0f, and less than 1f.</summary>
        public float NextRandomFloat() => (float)random.NextDouble();    
        
		/// <summary>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</summary>
        public double NextRandomDouble() => random.NextDouble();  
        
		/// <summary>Fills the elements of a specified array of bytes with random numbers.</summary>  
        public void NextRandomBytes(byte[] buffer) => random.NextBytes(buffer);

        /// <summary>
        /// Returns an unsigned integer representing a random color with full opacity
        /// </summary>
        public uint NextRandomRGBColor => (uint)(0xFF000000 | (random.Next(0xFFFFFF)));
    }
}
FILE: BannerColorPicker.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.Core;

namespace Bannerlord.GameMaster.Banners
{
    /// <summary>
    /// Provides methods for selecting banner colors from the game's palette
    /// and finding complementary colors for banner design.
    /// </summary>
    public static class BannerColorPicker
    {
        private static readonly Random _random = new Random();

        /// MARK: GetRandomColorID
        /// <summary>
        /// Gets a random color ID from the banner palette.
        /// </summary>
        /// <returns>A valid color ID that exists in the palette.</returns>
        public static int GetRandomColorId()
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            var colorIds = palette.Keys.ToList();
            return colorIds[_random.Next(colorIds.Count)];
        }

        /// MARK: GetLighterColor
        /// <summary>
        /// Finds a lighter complementary color from the palette based on the given color ID.
        /// </summary>
        /// <param name="baseColorId">The base color ID to find a lighter complement for.</param>
        /// <param name="minLuminanceDifference">Minimum brightness difference (0.0 to 1.0). Default is 0.15.</param>
        /// <returns>A color ID for a lighter color, or the base color if no suitable lighter color exists.</returns>
        public static int GetLighterComplementaryColor(int baseColorId, float minLuminanceDifference = 0.15f)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            
            if (!palette.ContainsKey(baseColorId))
                return baseColorId;

            var baseColor = palette[baseColorId];
            float baseLuminance = CalculateLuminance(baseColor.Color);

            // Find colors that are lighter than the base color
            var lighterColors = palette
                .Where(kvp =>
                {
                    float luminance = CalculateLuminance(kvp.Value.Color);
                    return luminance > baseLuminance + minLuminanceDifference;
                })
                .ToList();

            if (!lighterColors.Any())
            {
                // If no lighter colors found with minimum difference, try without minimum
                lighterColors = palette
                    .Where(kvp => CalculateLuminance(kvp.Value.Color) > baseLuminance)
                    .ToList();
            }

            if (!lighterColors.Any())
                return baseColorId; // Return base color if no lighter colors exist

            // Find the color with the best complementary relationship
            return FindBestComplementaryColor(baseColor.Color, lighterColors, true);
        }

        /// MARK: GetDarkerColor
        /// <summary>
        /// Finds a darker complementary color from the palette based on the given color ID.
        /// </summary>
        /// <param name="baseColorId">The base color ID to find a darker complement for.</param>
        /// <param name="minLuminanceDifference">Minimum brightness difference (0.0 to 1.0). Default is 0.15.</param>
        /// <returns>A color ID for a darker color, or the base color if no suitable darker color exists.</returns>
        public static int GetDarkerComplementaryColor(int baseColorId, float minLuminanceDifference = 0.15f)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            
            if (!palette.ContainsKey(baseColorId))
                return baseColorId;

            var baseColor = palette[baseColorId];
            float baseLuminance = CalculateLuminance(baseColor.Color);

            // Find colors that are darker than the base color
            var darkerColors = palette
                .Where(kvp =>
                {
                    float luminance = CalculateLuminance(kvp.Value.Color);
                    return luminance < baseLuminance - minLuminanceDifference;
                })
                .ToList();

            if (!darkerColors.Any())
            {
                // If no darker colors found with minimum difference, try without minimum
                darkerColors = palette
                    .Where(kvp => CalculateLuminance(kvp.Value.Color) < baseLuminance)
                    .ToList();
            }

            if (!darkerColors.Any())
                return baseColorId; // Return base color if no darker colors exist

            // Find the color with the best complementary relationship
            return FindBestComplementaryColor(baseColor.Color, darkerColors, false);
        }

        /// MARK: GetContrastingColor
        /// <summary>
        /// Finds a contrasting color from the palette that provides maximum visibility against the base color.
        /// Prefers colors with high luminance difference and complementary hues for better emblem visibility.
        /// </summary>
        /// <param name="baseColorId">The base color ID to find a contrasting color for.</param>
        /// <param name="preferLighter">If true, returns a lighter color; if false, returns a darker color.</param>
        /// <param name="minLuminanceDifference">Minimum brightness difference (0.0 to 1.0). Default is 0.3 for stronger contrast.</param>
        /// <returns>A color ID for a contrasting color, or the base color if no suitable contrasting color exists.</returns>
        public static int GetContrastingColor(int baseColorId, bool preferLighter, float minLuminanceDifference = 0.3f)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            
            if (!palette.ContainsKey(baseColorId))
                return baseColorId;

            var baseColor = palette[baseColorId];
            float baseLuminance = CalculateLuminance(baseColor.Color);

            // Find colors with high luminance difference
            var contrastingColors = palette
                .Where(kvp =>
                {
                    float luminance = CalculateLuminance(kvp.Value.Color);
                    if (preferLighter)
                        return luminance > baseLuminance + minLuminanceDifference;
                    else
                        return luminance < baseLuminance - minLuminanceDifference;
                })
                .ToList();

            if (!contrastingColors.Any())
            {
                // If no colors found with minimum difference, lower the threshold
                contrastingColors = palette
                    .Where(kvp =>
                    {
                        float luminance = CalculateLuminance(kvp.Value.Color);
                        if (preferLighter)
                            return luminance > baseLuminance + 0.15f;
                        else
                            return luminance < baseLuminance - 0.15f;
                    })
                    .ToList();
            }

            if (!contrastingColors.Any())
            {
                // Last resort: any color in the right direction
                contrastingColors = palette
                    .Where(kvp =>
                    {
                        float luminance = CalculateLuminance(kvp.Value.Color);
                        return preferLighter ? luminance > baseLuminance : luminance < baseLuminance;
                    })
                    .ToList();
            }

            if (!contrastingColors.Any())
                return baseColorId;

            // Find the color with the best contrasting relationship
            return FindBestContrastingColor(baseColor.Color, contrastingColors);
        }

        /// MARK: GetColorScheme
        /// <summary>
        /// Gets a complete banner color scheme with main background, secondary background, and emblem colors.
        /// Automatically selects the best theme (standard or alternative) based on the main color's luminance.
        /// For lighter main colors, uses darker secondary and emblem. For darker main colors, uses lighter emblem.
        /// </summary>
        /// <param name="mainBackgroundId">Output: The main background color ID.</param>
        /// <param name="secondaryBackgroundId">Output: The secondary background color ID.</param>
        /// <param name="emblemColorId">Output: The emblem color ID (high contrast).</param>
        public static void GetBannerColorScheme(out int mainBackgroundId, out int secondaryBackgroundId, out int emblemColorId)
        {
            // Pick a random main background color
            mainBackgroundId = GetRandomColorId();

            // Automatically choose the best theme based on the main color
            GetBannerColorScheme(mainBackgroundId, out secondaryBackgroundId, out emblemColorId);
        }

        /// MARK: GetColorScheme
        /// <summary>
        /// Gets a complete banner color scheme with main background, secondary background, and emblem colors
        /// for a specific main color. Automatically selects the best theme based on the main color's luminance.
        /// For lighter main colors (luminance > 0.6), uses lighter secondary and darker emblem.
        /// For darker main colors (luminance <= 0.6), uses darker secondary and lighter emblem.
        /// </summary>
        /// <param name="mainBackgroundId">The main background color ID to use.</param>
        /// <param name="secondaryBackgroundId">Output: The secondary background color ID.</param>
        /// <param name="emblemColorId">Output: The emblem color ID (high contrast).</param>
        public static void GetBannerColorScheme(int mainBackgroundId, out int secondaryBackgroundId, out int emblemColorId)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            
            if (!palette.ContainsKey(mainBackgroundId))
            {
                // If invalid color, fall back to random
                mainBackgroundId = GetRandomColorId();
            }

            var mainColor = palette[mainBackgroundId];
            float mainLuminance = CalculateLuminance(mainColor.Color);

            // If the main color is very light (close to white), use alternative scheme (lighter secondary, darker emblem)
            // Otherwise use standard scheme (darker secondary, lighter emblem)
            if (mainLuminance > 0.6f)
            {
                // Light main color: use lighter secondary and darker emblem
                secondaryBackgroundId = GetLighterComplementaryColor(mainBackgroundId);
                emblemColorId = GetContrastingColor(mainBackgroundId, false);
            }
            else
            {
                // Dark/medium main color: use darker secondary and lighter emblem
                secondaryBackgroundId = GetDarkerComplementaryColor(mainBackgroundId);
                emblemColorId = GetContrastingColor(mainBackgroundId, true);
            }
        }

        /// MARK: GetAlternativeScheme
        /// <summary>
        /// Gets an alternative banner color scheme with lighter secondary background and darker emblem.
        /// Automatically selects a random main color and applies the alternative theme.
        /// Best for creating banners with lighter overall appearance.
        /// </summary>
        /// <param name="mainBackgroundId">Output: The main background color ID.</param>
        /// <param name="secondaryBackgroundId">Output: The secondary background color ID (lighter).</param>
        /// <param name="emblemColorId">Output: The emblem color ID (darker, high contrast).</param>
        public static void GetAlternativeBannerColorScheme(out int mainBackgroundId, out int secondaryBackgroundId, out int emblemColorId)
        {
            // Pick a random main background color
            mainBackgroundId = GetRandomColorId();

            // Apply the alternative theme
            GetAlternativeBannerColorScheme(mainBackgroundId, out secondaryBackgroundId, out emblemColorId);
        }

        /// MARK: GetAlternativeScheme
        /// <summary>
        /// Gets an alternative banner color scheme with lighter secondary background and darker emblem
        /// for a specific main color. Always uses the alternative theme regardless of luminance.
        /// Best for creating banners with lighter overall appearance.
        /// </summary>
        /// <param name="mainBackgroundId">The main background color ID to use.</param>
        /// <param name="secondaryBackgroundId">Output: The secondary background color ID (lighter).</param>
        /// <param name="emblemColorId">Output: The emblem color ID (darker, high contrast).</param>
        public static void GetAlternativeBannerColorScheme(int mainBackgroundId, out int secondaryBackgroundId, out int emblemColorId)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            
            if (!palette.ContainsKey(mainBackgroundId))
            {
                // If invalid color, fall back to random
                mainBackgroundId = GetRandomColorId();
            }

            // Get a lighter color for secondary background
            secondaryBackgroundId = GetLighterComplementaryColor(mainBackgroundId);

            // Get a high-contrast darker color for emblem visibility
            emblemColorId = GetContrastingColor(mainBackgroundId, false);
        }

        /// MARK: GetStandardScheme
        /// <summary>
        /// Gets a standard banner color scheme with darker secondary background and lighter emblem
        /// for a specific main color. Always uses the standard theme regardless of luminance.
        /// Best for creating banners with darker overall appearance.
        /// </summary>
        /// <param name="mainBackgroundId">The main background color ID to use.</param>
        /// <param name="secondaryBackgroundId">Output: The secondary background color ID (darker).</param>
        /// <param name="emblemColorId">Output: The emblem color ID (lighter, high contrast).</param>
        public static void GetStandardBannerColorScheme(int mainBackgroundId, out int secondaryBackgroundId, out int emblemColorId)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            
            if (!palette.ContainsKey(mainBackgroundId))
            {
                // If invalid color, fall back to random
                mainBackgroundId = GetRandomColorId();
            }

            // Get a darker color for secondary background
            secondaryBackgroundId = GetDarkerComplementaryColor(mainBackgroundId);

            // Get a high-contrast lighter color for emblem visibility
            emblemColorId = GetContrastingColor(mainBackgroundId, true);
        }

        /// MARK: CalculateLuminance
        /// <summary>
        /// Calculates the relative luminance of a color using the standard formula.
        /// </summary>
        /// <param name="colorValue">The uint color value in ARGB format.</param>
        /// <returns>Luminance value between 0.0 (black) and 1.0 (white).</returns>
        private static float CalculateLuminance(uint colorValue)
        {
            // Extract RGB components from uint (ARGB format)
            float r = ((colorValue >> 16) & 0xFF) / 255f;
            float g = ((colorValue >> 8) & 0xFF) / 255f;
            float b = (colorValue & 0xFF) / 255f;

            // Use standard relative luminance formula (ITU-R BT.709)
            return 0.2126f * r + 0.7152f * g + 0.0722f * b;
        }

        /// MARK: CalculateHueDiff
        /// <summary>
        /// Calculates hue similarity between two colors (0 = same hue, 180 = opposite).
        /// </summary>
        private static float CalculateHueDifference(uint color1, uint color2)
        {
            float h1 = GetHue(color1);
            float h2 = GetHue(color2);

            float diff = Math.Abs(h1 - h2);
            // Handle wrap-around (e.g., 350Â° and 10Â° are close)
            if (diff > 180f)
                diff = 360f - diff;

            return diff;
        }

        /// MARK: GetHue
        /// <summary>
        /// Gets the hue of a color in degrees (0-360).
        /// </summary>
        private static float GetHue(uint colorValue)
        {
            float r = ((colorValue >> 16) & 0xFF) / 255f;
            float g = ((colorValue >> 8) & 0xFF) / 255f;
            float b = (colorValue & 0xFF) / 255f;

            float max = Math.Max(r, Math.Max(g, b));
            float min = Math.Min(r, Math.Min(g, b));
            float delta = max - min;

            if (delta == 0)
                return 0; // Gray color, no hue

            float hue;
            if (max == r)
                hue = 60f * (((g - b) / delta) % 6);
            else if (max == g)
                hue = 60f * (((b - r) / delta) + 2);
            else
                hue = 60f * (((r - g) / delta) + 4);

            if (hue < 0)
                hue += 360f;

            return hue;
        }

        /// MARK: GetSaturation
        /// <summary>
        /// Gets the saturation of a color (0-1).
        /// </summary>
        private static float GetSaturation(uint colorValue)
        {
            float r = ((colorValue >> 16) & 0xFF) / 255f;
            float g = ((colorValue >> 8) & 0xFF) / 255f;
            float b = (colorValue & 0xFF) / 255f;

            float max = Math.Max(r, Math.Max(g, b));
            float min = Math.Min(r, Math.Min(g, b));
            float delta = max - min;

            if (max == 0)
                return 0;

            return delta / max;
        }

        /// MARK: ComplementaryColor
        /// <summary>
        /// Finds the best complementary color from a list of candidates.
        /// Prefers colors with similar hue but different brightness, avoiding harsh contrasts.
        /// </summary>
        private static int FindBestComplementaryColor(uint baseColor, List<KeyValuePair<int, BannerColor>> candidates, bool preferLighter)
        {
            if (!candidates.Any())
                return -1;

            float baseHue = GetHue(baseColor);
            float baseSaturation = GetSaturation(baseColor);

            // Score each candidate color
            var scoredCandidates = candidates.Select(kvp =>
            {
                float hueDiff = CalculateHueDifference(baseColor, kvp.Value.Color);
                float saturation = GetSaturation(kvp.Value.Color);
                
                // Prefer colors with similar hue (analogous colors work well for banners)
                float hueScore = 1f - (hueDiff / 180f); // 0-1, higher is better
                
                // Prefer colors with similar saturation (creates harmony)
                float saturationScore = 1f - Math.Abs(baseSaturation - saturation);
                
                // Combine scores (weighted toward hue similarity)
                float totalScore = (hueScore * 0.6f) + (saturationScore * 0.4f);

                return new { ColorId = kvp.Key, Score = totalScore };
            })
            .OrderByDescending(x => x.Score)
            .ToList();

            // Return the best scoring color, with some randomness for variety
            // 70% chance to pick the best, 20% second best, 10% third best
            int index = 0;
            float roll = (float)_random.NextDouble();
            if (roll > 0.7f && scoredCandidates.Count > 1)
                index = 1;
            if (roll > 0.9f && scoredCandidates.Count > 2)
                index = 2;

            return scoredCandidates[index].ColorId;
        }

        /// MARK: ContrastingColor
        /// <summary>
        /// Finds the best contrasting color from a list of candidates.
        /// Prefers colors with complementary hues and high saturation for maximum visibility.
        /// </summary>
        private static int FindBestContrastingColor(uint baseColor, List<KeyValuePair<int, BannerColor>> candidates)
        {
            if (!candidates.Any())
                return -1;

            float baseHue = GetHue(baseColor);
            float baseLuminance = CalculateLuminance(baseColor);

            // Score each candidate color for contrast
            var scoredCandidates = candidates.Select(kvp =>
            {
                float hueDiff = CalculateHueDifference(baseColor, kvp.Value.Color);
                float saturation = GetSaturation(kvp.Value.Color);
                float luminance = CalculateLuminance(kvp.Value.Color);
                
                // Prefer colors with complementary hues (120-180 degrees apart)
                float hueScore = 0f;
                if (hueDiff >= 120f)
                    hueScore = (hueDiff - 120f) / 60f; // Max score at 180 degrees
                else
                    hueScore = hueDiff / 120f * 0.5f; // Lower score for closer hues
                
                hueScore = Math.Min(hueScore, 1f);
                
                // Prefer high saturation (vibrant colors stand out better)
                float saturationScore = saturation;
                
                // Prefer high luminance difference
                float luminanceScore = Math.Abs(luminance - baseLuminance);
                
                // Combine scores (weighted toward luminance and hue contrast)
                float totalScore = (luminanceScore * 0.5f) + (hueScore * 0.3f) + (saturationScore * 0.2f);

                return new { ColorId = kvp.Key, Score = totalScore };
            })
            .OrderByDescending(x => x.Score)
            .ToList();

            // Return the best scoring color, with some randomness for variety
            // 70% chance to pick the best, 20% second best, 10% third best
            int index = 0;
            float roll = (float)_random.NextDouble();
            if (roll > 0.7f && scoredCandidates.Count > 1)
                index = 1;
            if (roll > 0.9f && scoredCandidates.Count > 2)
                index = 2;

            return scoredCandidates[index].ColorId;
        }

        /// MARK: GetColorInfo
        /// <summary>
        /// Gets color information for debugging purposes.
        /// </summary>
        /// <param name="colorId">The color ID to get information for.</param>
        /// <returns>A string containing color information, or null if the color doesn't exist.</returns>
        public static string GetColorInfo(int colorId)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            if (!palette.ContainsKey(colorId))
                return null;

            var color = palette[colorId];
            float luminance = CalculateLuminance(color.Color);
            float hue = GetHue(color.Color);
            float saturation = GetSaturation(color.Color);

            uint colorValue = color.Color;
            byte r = (byte)((colorValue >> 16) & 0xFF);
            byte g = (byte)((colorValue >> 8) & 0xFF);
            byte b = (byte)(colorValue & 0xFF);

            return $"Color ID {colorId}: RGB({r},{g},{b}) Hex:#{r:X2}{g:X2}{b:X2} " +
                   $"Luminance:{luminance:F3} Hue:{hue:F1}Â° Saturation:{saturation:F3}";
        }

        /// MARK: AreColorsSimilar
        /// <summary>
        /// Determines if two colors are similar based on perceptual difference.
        /// Uses luminance, hue, and saturation to calculate color similarity.
        /// </summary>
        /// <param name="colorId1">First color ID from banner palette.</param>
        /// <param name="colorId2">Second color ID from banner palette.</param>
        /// <param name="threshold">Perceptual similarity threshold (0.0-1.0). Lower values mean more strict matching. Default is 0.2.</param>
        /// <returns>True if colors are perceptually similar, false otherwise.</returns>
        public static bool AreColorsSimilar(int colorId1, int colorId2, float threshold = 0.2f)
        {
            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            
            // Exact match check
            if (colorId1 == colorId2)
                return true;

            // Validate color IDs exist in palette
            if (!palette.ContainsKey(colorId1) || !palette.ContainsKey(colorId2))
                return false;

            uint color1 = palette[colorId1].Color;
            uint color2 = palette[colorId2].Color;

            // Calculate perceptual differences
            float luminance1 = CalculateLuminance(color1);
            float luminance2 = CalculateLuminance(color2);
            float luminanceDiff = Math.Abs(luminance1 - luminance2);

            float hue1 = GetHue(color1);
            float hue2 = GetHue(color2);
            float hueDiff = CalculateHueDifference(color1, color2) / 180f; // Normalize to 0-1

            float saturation1 = GetSaturation(color1);
            float saturation2 = GetSaturation(color2);
            float saturationDiff = Math.Abs(saturation1 - saturation2);

            // Calculate weighted perceptual difference
            // Luminance is most important for distinguishing colors, then hue, then saturation
            float perceptualDifference = (luminanceDiff * 0.5f) + (hueDiff * 0.35f) + (saturationDiff * 0.15f);

            return perceptualDifference < threshold;
        }

        /// MARK: AreColorsSimilar
        /// <summary>
        /// Determines if two colors (by uint value) are similar based on perceptual difference.
        /// This overload is for compatibility with existing code using raw color values.
        /// </summary>
        /// <param name="color1">First color as uint value.</param>
        /// <param name="color2">Second color as uint value.</param>
        /// <param name="threshold">Perceptual similarity threshold (0.0-1.0). Lower values mean more strict matching. Default is 0.2.</param>
        /// <returns>True if colors are perceptually similar, false otherwise.</returns>
        public static bool AreColorsSimilar(uint color1, uint color2, float threshold = 0.2f)
        {
            // Exact match check
            if (color1 == color2)
                return true;

            // Calculate perceptual differences
            float luminance1 = CalculateLuminance(color1);
            float luminance2 = CalculateLuminance(color2);
            float luminanceDiff = Math.Abs(luminance1 - luminance2);

            float hueDiff = CalculateHueDifference(color1, color2) / 180f; // Normalize to 0-1

            float saturation1 = GetSaturation(color1);
            float saturation2 = GetSaturation(color2);
            float saturationDiff = Math.Abs(saturation1 - saturation2);

            // Calculate weighted perceptual difference
            float perceptualDifference = (luminanceDiff * 0.5f) + (hueDiff * 0.35f) + (saturationDiff * 0.15f);

            return perceptualDifference < threshold;
        }

        /// MARK: GetUniqueClanColor
        /// <summary>
        /// Gets the most unique color ID from the banner palette compared to existing clans.
        /// Ensures the selected color is perceptually distinct from all existing clan colors.
        /// </summary>
        /// <param name="minimumThreshold">Minimum perceptual difference threshold (0.0-1.0). Default is 0.15 for good distinction.</param>
        /// <returns>A banner palette color ID that is maximally distinct from existing clan colors.</returns>
        public static int GetUniqueClanColorId(float minimumThreshold = 0.15f)
        {   
            int maxAttempts = 50; //Max attempts before color threshold is lowered

            var palette = BannerManager.Instance.ReadOnlyColorPalette;
            var colorIds = palette.Keys.ToList();

            // Start with a high threshold for maximum uniqueness, then gradually decrease
            for (float similarThreshold = 0.5f; similarThreshold >= minimumThreshold; similarThreshold -= 0.05f)
            {
                // Try multiple random colors at this threshold level
                for (int attempt = 0; attempt < maxAttempts; attempt++)
                {
                    int randomColorId = colorIds[_random.Next(colorIds.Count)];
                    bool isColorSimilar = false;

                    foreach (Clan clan in Clan.All)
                    {
                        if (clan.IsEliminated)
                            continue;

                        // Check if similar to this clan's color
                        if (AreColorsSimilar(palette[randomColorId].Color, clan.Color, similarThreshold))
                        {
                            isColorSimilar = true;
                            break;
                        }
                    }

                    // Color is sufficiently unique
                    if (!isColorSimilar)
                        return randomColorId;
                }
            }

            // If no unique color found even at minimum threshold, return a random color
            return colorIds[_random.Next(colorIds.Count)];
        }
    }
}

FILE: BannerExtensions.cs
using TaleWorlds.Core;

namespace Bannerlord.GameMaster.Banners
{
    /// <summary>
    /// Extension methods for Banner objects.
    /// </summary>
    public static class BannerExtensions
    {
        /// MARK: ApplyRandomScheme
        /// <summary>
        /// Applies a random color scheme to the banner with high-contrast emblem.
        /// Automatically selects the best theme based on the randomly chosen main color's luminance.
        /// For lighter main colors, uses lighter secondary and darker emblem.
        /// For darker main colors, uses darker secondary and lighter emblem.
        /// </summary>
        /// <param name="banner">The banner to apply colors to.</param>
        /// <returns>The banner instance for method chaining.</returns>
        public static Banner ApplyRandomColorScheme(this Banner banner)
        {
            BannerColorPicker.GetBannerColorScheme(
                out int primaryColorId,
                out int secondaryColorId,
                out int iconColorId);

            banner.SetPrimaryColorId(primaryColorId);
            banner.SetSecondaryColorId(secondaryColorId);
            banner.SetIconColorId(iconColorId);

            return banner;
        }

        /// MARK: ApplyColorScheme
        /// <summary>
        /// Applies a color scheme to the banner using a specific primary color with high-contrast emblem.
        /// Automatically selects the best theme based on the provided main color's luminance.
        /// For lighter main colors (luminance > 0.6), uses lighter secondary and darker emblem.
        /// For darker main colors (luminance <= 0.6), uses darker secondary and lighter emblem.
        /// </summary>
        /// <param name="banner">The banner to apply colors to.</param>
        /// <param name="primaryColorId">The primary (main background) color ID to use.</param>
        /// <returns>The banner instance for method chaining.</returns>
        public static Banner ApplyColorScheme(this Banner banner, int primaryColorId)
        {
            BannerColorPicker.GetBannerColorScheme(
                primaryColorId,
                out int secondaryColorId,
                out int iconColorId);

            banner.SetPrimaryColorId(primaryColorId);
            banner.SetSecondaryColorId(secondaryColorId);
            banner.SetIconColorId(iconColorId);

            return banner;
        }

        /// MARK: ApplyAltColorScheme
        /// <summary>
        /// Applies an alternative random color scheme to the banner with high-contrast emblem.
        /// Always uses lighter secondary background and darker emblem regardless of main color luminance.
        /// Best for creating banners with lighter overall appearance.
        /// </summary>
        /// <param name="banner">The banner to apply colors to.</param>
        /// <returns>The banner instance for method chaining.</returns>
        public static Banner ApplyAlternativeColorScheme(this Banner banner)
        {
            BannerColorPicker.GetAlternativeBannerColorScheme(
                out int primaryColorId,
                out int secondaryColorId,
                out int iconColorId);

            banner.SetPrimaryColorId(primaryColorId);
            banner.SetSecondaryColorId(secondaryColorId);
            banner.SetIconColorId(iconColorId);

            return banner;
        }

        /// MARK: ApplyAltColorScheme 
        /// <summary>
        /// Applies an alternative color scheme to the banner using a specific primary color with high-contrast emblem.
        /// Always uses lighter secondary background and darker emblem regardless of main color luminance.
        /// Best for creating banners with lighter overall appearance.
        /// </summary>
        /// <param name="banner">The banner to apply colors to.</param>
        /// <param name="primaryColorId">The primary (main background) color ID to use.</param>
        /// <returns>The banner instance for method chaining.</returns>
        public static Banner ApplyAlternativeColorScheme(this Banner banner, int primaryColorId)
        {
            BannerColorPicker.GetAlternativeBannerColorScheme(
                primaryColorId,
                out int secondaryColorId,
                out int iconColorId);

            banner.SetPrimaryColorId(primaryColorId);
            banner.SetSecondaryColorId(secondaryColorId);
            banner.SetIconColorId(iconColorId);

            return banner;
        }

        /// MARK: ApplyStandardScheme
        /// <summary>
        /// Applies a standard color scheme to the banner using a specific primary color with high-contrast emblem.
        /// Always uses darker secondary background and lighter emblem regardless of main color luminance.
        /// Best for creating banners with darker overall appearance.
        /// </summary>
        /// <param name="banner">The banner to apply colors to.</param>
        /// <param name="primaryColorId">The primary (main background) color ID to use.</param>
        /// <returns>The banner instance for method chaining.</returns>
        public static Banner ApplyStandardColorScheme(this Banner banner, int primaryColorId)
        {
            BannerColorPicker.GetStandardBannerColorScheme(
                primaryColorId,
                out int secondaryColorId,
                out int iconColorId);

            banner.SetPrimaryColorId(primaryColorId);
            banner.SetSecondaryColorId(secondaryColorId);
            banner.SetIconColorId(iconColorId);

            return banner;
        }

        /// MARK: ApplyUniqueScheme
        /// <summary>
        /// Applies a unique color scheme to the banner that is distinct from existing clan colors.
        /// Automatically finds a unique primary color from the banner palette that differs from all existing clans,
        /// then applies the best theme (standard or alternative) based on that color's luminance.
        /// Ideal for creating new clans with visually distinct banners.
        /// </summary>
        /// <param name="banner">The banner to apply colors to.</param>
        /// <param name="minimumThreshold">Minimum perceptual difference from existing clans (0.0-1.0). Default is 0.15 for good distinction.</param>
        /// <returns>The banner instance for method chaining.</returns>
        public static Banner ApplyUniqueColorScheme(this Banner banner, float minimumThreshold = 0.15f)
        {
            int uniquePrimaryColorId = BannerColorPicker.GetUniqueClanColorId(minimumThreshold);

            BannerColorPicker.GetBannerColorScheme(
                uniquePrimaryColorId,
                out int secondaryColorId,
                out int iconColorId);

            banner.SetPrimaryColorId(uniquePrimaryColorId);
            banner.SetSecondaryColorId(secondaryColorId);
            banner.SetIconColorId(iconColorId);

            return banner;
        }
    }
}

FILE: BeardTags.cs
namespace Bannerlord.GameMaster.Characters
{
    /// <summary>
    /// Filters which beards are allowed </br>
    /// Female Character should ignore any beard tags </br>
    /// Multiple tags can be combined to allow a combination (ex: "tag1;tag2;tag3"), some pre-combined tags are provided
    /// </summary>
    public static class BeardTags
    {
        /// <summary>
        /// Empty String: All Beard styles allowed
        /// </summary>
        public static readonly string All = "";        
        
        /// <summary>
        /// "clean_shaven" : Forces no beard
        /// </summary>
        public static readonly string NoBeard = "clean_shaven";       
        
        /// <summary>
        /// "full_beard" : Full beard styles only
        /// </summary>
        public static readonly string FullBeard = "full_beard";

        /// <summary>
        /// "goatee" : Goatee styles only
        /// </summary>
        public static readonly string Goatee = "goatee";             
        
        /// <summary>
        /// "mustache" : Mustache styles
        /// </summary>
        public static readonly string Mustache = "mustache";       
        
        /// <summary>
        /// "stubble" : Stubble styles
        /// </summary>
        public static readonly string Stubble = "stubble";

        /// <summary>
        /// "chin_beard" : Chin Beards
        /// </summary>
        public static readonly string ChinBeard = "chin_beard";

        /// <summary>
        /// "mutton_chops" : Sideburns / Mutton chops
        /// </summary>
        public static readonly string MuttonChops = "mutton_chops";
    }
}
FILE: CharacterTemplates.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using NavalDLC;
using Bannerlord.GameMaster.Cultures;

namespace Bannerlord.GameMaster.Characters
{
	public class CharacterTemplatePooler
	{
		List<CharacterObject> _allTemplates;
		List<CharacterObject> _femaleTemplates;
		List<CharacterObject> _maleTemplates;

		List<CharacterObject> _mainFactionTemplates;
		List<CharacterObject> _mainFactionMaleTemplates;
		List<CharacterObject> _mainFactionFemaleTemplates;

		List<CharacterObject> _banditTemplates;
		List<CharacterObject> _banditFemaleTemplates;
		List<CharacterObject> _banditMaleTemplates;

		public string Debug_CountTemplates()
		{
			int all = 0;
			int female = 0;
			int heroAll = 0;
			int heroFemale = 0;

			foreach (CharacterObject character in AllTemplates)
			{
				if (character.Occupation == Occupation.Lord)
				{
					all++;
					if (character.IsFemale)
						female++;
				}
				else if (character.IsHero)
				{
					heroAll++;
					if (character.IsFemale)
						heroFemale++;
				}
			}

			return $"Occupation Lord: {all}, Female: {female}\nIsHero: {heroAll}, Female: {heroFemale}";
		}

		//If backing field is null, get list (Allows list to be cached and reused without relooping eveytime) or not take any memory if that specific list is never used
		public List<CharacterObject> AllTemplates => _allTemplates ??= GetAllTemplates();
		public List<CharacterObject> FemaleTemplates => _femaleTemplates ??= FilterByGender(AllTemplates, true);
		public List<CharacterObject> MaleTemplates => _maleTemplates ??= FilterByGender(AllTemplates, false);

		/// <summary>
		/// Main Map factions
		/// </summary>
		public List<CharacterObject> MainFactionTemplates => _mainFactionTemplates ??= GetMainFactionTemplates();
		public List<CharacterObject> MainFactionFemaleTemplates => _mainFactionFemaleTemplates ??= FilterByGender(MainFactionTemplates, true);
		public List<CharacterObject> MainFactionMaleTemplates => _mainFactionMaleTemplates ??= FilterByGender(MainFactionTemplates, false);

		/// <summary>
		/// Loots, bandits, and pirates
		/// </summary>
		public List<CharacterObject> BanditTemplates => _banditTemplates ??= GetBanditTemplates();
		public List<CharacterObject> BanditFemaleTemplates => _banditFemaleTemplates ??= FilterByGender(BanditTemplates, true);
		public List<CharacterObject> BanditMaleTemplates => _banditMaleTemplates ??= FilterByGender(BanditTemplates, false);

		/// <summary>
		/// Gets all templates templates
		/// </summary>
		List<CharacterObject> GetAllTemplates()
		{
			List<CharacterObject> templates = new();

			foreach (CharacterObject characterObject in CharacterObject.All)
			{
				if (characterObject.IsTemplate)
					templates.Add(characterObject);
			}

			return templates;
		}

		/// <summary>
		/// Gets templates of all the main factions
		/// </summary>
		List<CharacterObject> GetMainFactionTemplates()
		{
			List<CharacterObject> templates = new();

			foreach (CharacterObject characterObject in AllTemplates)
			{
				if (characterObject.Culture.IsMainCulture)
					templates.Add(characterObject);
			}

			return templates;
		}

		/// <summary>
		/// Gets templates of all the bandit factions
		/// </summary>
		List<CharacterObject> GetBanditTemplates()
		{
			List<CharacterObject> templates = new();

			foreach (CharacterObject characterObject in AllTemplates)
			{
				if (characterObject.Culture.IsBandit || characterObject.IsPirate())
					templates.Add(characterObject);
			}

			return templates;
		}

		/// <summary>
		/// Filters the by the specified gender using the supplied list
		/// </summary>
		List<CharacterObject> FilterByGender(List<CharacterObject> listToFilter, bool isFemale)
		{
			List<CharacterObject> genderTemplates = new();

			if (listToFilter == null)
				return genderTemplates; // Should I return null instead?

			foreach (CharacterObject template in listToFilter)
			{
				if (template.IsFemale == isFemale)
					genderTemplates.Add(template);
			}

			return genderTemplates;
		}

		/// <summary>
		/// Filters character objects to ONLY include Lord and Wanderer occupations.
		/// Includes both templates and actual characters for maximum variety.
		/// Excludes notables (RuralNotable, Headman, Artisan, Merchant, etc.) to prevent occupation conflicts.
		/// Excludes dead heroes to avoid using deceased character appearances.
		/// </summary>
		List<CharacterObject> FilterToLordAndWandererCharacters(List<CharacterObject> listToFilter)
		{
			List<CharacterObject> heroCharacters = new();
	
			if (listToFilter == null)
				return heroCharacters;
	
			foreach (CharacterObject character in listToFilter)
			{
				// Check if it's a dead hero - skip if dead
				if (character.IsHero && character.HeroObject != null && !character.HeroObject.IsAlive)
				{
					continue;
				}
	
				// ONLY include Lord and Wanderer occupations
				// This excludes ALL notable types (RuralNotable, Headman, Artisan, Merchant, GangLeader, Preacher)
				// and also excludes Soldiers
				if (character.Occupation == Occupation.Lord || character.Occupation == Occupation.Wanderer)
				{
					heroCharacters.Add(character);
				}
			}
	
			return heroCharacters;
		}

		/// <summary>
		/// Gets the character templates of a single specified culture </br>
		/// Use CultureLookup class to easily retrieve CultureObjects to use.
		/// </summary>
		public List<CharacterObject> GetCulturalTemplates(CultureObject culture)
		{
			List<CharacterObject> templates = new();

			foreach (CharacterObject template in AllTemplates)
			{
				if (template.Culture == culture)
					templates.Add(template);
			}

			return templates;
		}

		/// <summary>
		/// Gets ONLY Lord and Wanderer character objects (both templates and actual characters) for a single specified culture.
		/// Excludes notables and soldiers to prevent occupation conflicts.
		/// Safe for use in all hero creation (lords, wanderers, companions).
		/// </summary>
		public List<CharacterObject> GetLordAndWandererCharacters(CultureObject culture)
		{
			return FilterToLordAndWandererCharacters(GetCulturalTemplates(culture));
		}

		/// <summary>
		/// Gets the character templates of the specified gender for a single culture </br>
		/// Use CultureLookup class to easily retrieve CultureObjects to use. </br>
		/// if false is provided as an argument, males will be returned, if true is provided females are returned
		/// </summary>
		public List<CharacterObject> GetGenderCulturalTemplates(CultureObject culture, bool isFemale)
		{
			List<CharacterObject> templates = new();

			if (isFemale)
			{
				foreach (CharacterObject femaleTemplate in FemaleTemplates)
				{
					if (femaleTemplate.Culture == culture)
						templates.Add(femaleTemplate);
				}
			}

			else
			{
				foreach (CharacterObject template in MaleTemplates)
				{
					if (template.Culture == culture)
						templates.Add(template);
				}
			}

			return templates;
		}

		/// <summary>
		/// Gets character objects suitable for ALL hero creation (lords, wanderers, companions).
		/// Returns ONLY Lord and Wanderer occupations (both templates and actual characters).
		/// Excludes ALL notable occupations (Headman, RuralNotable, Artisan, Merchant, etc.) to prevent crashes.
		/// Excludes dead heroes to avoid using deceased character appearances.
		/// Provides maximum character variety, especially for female characters.
		/// </summary>
		public List<CharacterObject> GetAllHeroTemplatesFromFlags(CultureFlags cultureFlags, GenderFlags genderFlags)
		{
			List<CharacterObject> characters = new();
	
			// For group flags, we need to get all characters and filter
			if (cultureFlags == CultureFlags.AllCultures)
			{
				// Get all characters (templates and non-templates)
				var allChars = CharacterObject.All.ToList();
				characters = FilterToLordAndWandererCharacters(allChars);
			}
			else if (cultureFlags == CultureFlags.AllMainCultures)
			{
				// Get all main culture characters
				var mainCultureChars = CharacterObject.All
					.Where(c => c.Culture != null && c.Culture.IsMainCulture)
					.ToList();
				characters = FilterToLordAndWandererCharacters(mainCultureChars);
			}
			else if (cultureFlags == CultureFlags.AllBanditCultures)
			{
				// Get all bandit culture characters
				var banditChars = CharacterObject.All
					.Where(c => c.Culture != null && (c.Culture.IsBandit || c.IsPirate()))
					.ToList();
				characters = FilterToLordAndWandererCharacters(banditChars);
			}
			else
			{
				// Individual culture flags - accumulate characters from each specified culture
				if (cultureFlags.HasFlag(CultureFlags.Calradian))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.CalradianNeutral).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Aserai))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Aserai).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Battania))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Battania).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Empire))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Empire).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Khuzait))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Khuzait).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Nord))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Nord).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Sturgia))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Sturgia).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Vlandia))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Vlandia).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.Corsairs))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.Corsairs).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.DesertBandits))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.DesertBandits).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.ForestBandits))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.ForestBandits).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.MountainBandits))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.MountainBandits).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.SeaRaiders))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.SeaRaiders).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.SteppeBandits))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.SteppeBandits).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.DarshiSpecial))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.DarshiSpecial).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
	
				if (cultureFlags.HasFlag(CultureFlags.VakkenSpecial))
				{
					var cultureChars = CharacterObject.All.Where(c => c.Culture == CultureLookup.VakkenSpecial).ToList();
					characters.AddRange(FilterToLordAndWandererCharacters(cultureChars));
				}
			}
	
			// Apply gender filtering to accumulated characters
			return genderFlags switch
			{
				GenderFlags.Female => FilterByGender(characters, true),
				GenderFlags.Male => FilterByGender(characters, false),
				_ => characters
			};
		}

	}
}

FILE: GenderFlags.cs
using System;

namespace Bannerlord.GameMaster.Characters
{
	[Flags]
    public enum GenderFlags
    {
        None = 0,
        Female = 1 << 0, 
        Male = 1 << 1,    
        Either = Female | Male  
    }
}
FILE: HairCoveringTypes.cs
namespace Bannerlord.GameMaster.Characters
{
    /// <summary>
    /// Dertimines how hair is rendered depending on the type of headgear worn
    /// </summary>
    public static class HairCoveringType
    {
        /// <summary>
        /// 0: No hair covering - full hair visible (default for no helmet)
        /// </summary>
        public static readonly int None = 0;        
        
        /// <summary>
        /// 1: Light coverage (circlets, tiaras, open helmets)
        /// </summary>
        public static readonly int Light = 1;       
        
        /// <summary>
        /// 2: Medium coverage (half-helmets, hoods showing some hair)
        /// </summary>
        public static readonly int Medium = 2;           
        
        /// <summary>
        /// 3: Heavy coverage (most helmets, coifs)
        /// </summary>
        public static readonly int Heavy = 3;       
        
        /// <summary>
        /// 4: Full coverage (full enclosed helmets, complete head wraps)
        /// </summary>
        public static readonly int Full = 4;

        /// <summary>
        /// 5: Special case (specific cultural headgear)
        /// </summary>
        public static readonly int Special = 5;
    }
}
FILE: HairTags.cs
namespace Bannerlord.GameMaster.Characters
{
    /// <summary>
    /// Determines which hair styles are allowed </br>
    /// Multiple tags can be combined to allow a combination (ex: "tag1;tag2;tag3"), some pre-combined tags are provided
    /// </summary>
    public static class HairTags
    {
        /// <summary>
        /// Empty String: All Hair styles allowed
        /// </summary>
        public static readonly string All = "";        
        
        /// <summary>
        /// "bald" : Forces bald/no hair
        /// </summary>
        public static readonly string Bald = "bald";

        /// <summary>
        /// "shaved" : Shaved/Buzzed
        /// </summary>
        public static readonly string Shaved = "shaved";         
        
        /// <summary>
        /// "short" : Short hairstyles only
        /// </summary>
        public static readonly string Short = "short";

        /// <summary>
        /// "long" : Long hairstyles only
        /// </summary>
        public static readonly string Long = "long";             
        
        /// <summary>
        /// "braided" : Braided styles
        /// </summary>
        public static readonly string Braided = "braided";       
        
        /// <summary>
        /// "ponytail" : Ponytail styles
        /// </summary>
        public static readonly string Ponytails = "ponytail";

        /// <summary>
        /// "tied" : Tied styles
        /// </summary>
        public static readonly string Tied = "tied";

        /// <summary>
        /// "long;ponytail" : Normal attractive female hairstyles for normal people
        /// </summary>
        public static readonly string NormalFemale = "long;ponytail";

        /// <summary>
        /// "bald;shaved;short" : Normal common male hairstyles, may want to add long or others
        /// </summary>
        public static readonly string NormalMale = "bald;shaved;short";

        /// <summary>
        /// "shaved;short;long;ponytail;tied;braided" : Everything but bald
        /// </summary>
        public static readonly string NotBald = "shaved;short;long;ponytail;tied;braided";

        /// <summary>
        /// "short;long;ponytail;tied;braided" : Everything but bald and shaved
        /// </summary>
        public static readonly string NotBaldOrShaved = "short;long;ponytail;tied;braided";

        /// <summary>
        /// "long;ponytail;tied;braided" : All long hairstyles
        /// </summary>
        public static readonly string AllLong = "long;ponytail;tied;braided";

        /// <summary>
        /// bald;short;shaved;tied;braided : More viking stylish hair (Although viking can really be anything)
        /// </summary>
        public static readonly string Viking = "bald;short;shaved;tied;braided";

        /// <summary>
        /// "shaved;short;long;ponytail;tied;bald" : Everything but braided
        /// </summary>
        public static readonly string NotBraided = "shaved;short;long;ponytail;tied;bald";
    }
}
FILE: TattooTags.cs
namespace Bannerlord.GameMaster.Characters
{
    /// <summary>
    /// Filters which Tattoos / face paints are allowed </br>
    /// Multiple tags can be combined to allow a combination (ex: "tag1;tag2;tag3"), some pre-combined tags are provided
    /// </summary>
    public static class TattooTags
    {
        /// <summary>
        /// Empty String: All tattoos and face paints allowed
        /// </summary>
        public static readonly string All = "";        
        
        /// <summary>
        /// "none" : None allowed
        /// </summary>
        public static readonly string None = "none";       
        
        /// <summary>
        /// "tribal" : Tribal styled tattoos
        /// </summary>
        public static readonly string Tribal = "tribal";

        /// <summary>
        /// "war_paint" : War Paint styles only
        /// </summary>
        public static readonly string WarPaint = "war_paint";             
        
        /// <summary>
        /// "battanian" : Battanian culutural specific styles
        /// </summary>
        public static readonly string Battanian = "battanian";       
        
        /// <summary>
        /// "sturgian" : Sturgian culutural specific styles allowed
        /// </summary>
        public static readonly string Sturgian = "sturgian";

        /// <summary>
        /// "aserai" : Aserai culutural specific styles allowed
        /// </summary>
        public static readonly string Aserai = "aserai";

        /// <summary>
        /// "khuzait" : Khuzait culutural specific styles allowed
        /// </summary>
        public static readonly string Khuzait = "khuzait";

        /// <summary>
        /// "vlandian" : Vlandian culutural specific styles allowed (minimal)
        /// </summary>
        public static readonly string Vlandian = "vlandian";

        /// <summary>
        /// "empire" : Empire culutural specific styles allowed (minimal)
        /// </summary>
        public static readonly string Empire = "empire";
    }
}
FILE: ClanExtensions.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using TaleWorlds.Localization;

namespace Bannerlord.GameMaster.Clans
{
	#region Flags and Types

	[Flags]
	public enum ClanTypes
	{
		None = 0,
		Active = 1,
		Eliminated = 2,
		Bandit = 4,
		NonBandit = 8,
		MapFaction = 16,
		Noble = 32,
		MinorFaction = 64,
		Rebel = 128,
		Mercenary = 256,
		UnderMercenaryService = 512,
		Mafia = 1024,
		Outlaw = 2048,
		Nomad = 4096,
		Sect = 8192,
		WithoutKingdom = 16384,
		Empty = 32768,
		PlayerClan = 65536,
	}

	public static class ClanExtensions
	{
		/// <summary>
		/// Gets all clan type flags for this clan
		/// </summary>
		public static ClanTypes GetClanTypes(this Clan clan)
		{
			ClanTypes types = ClanTypes.None;

			if (clan.IsEliminated)
				types |= ClanTypes.Eliminated;
			else
				types |= ClanTypes.Active;

			if (clan.IsBanditFaction) types |= ClanTypes.Bandit;
			if (!clan.IsBanditFaction) types |= ClanTypes.NonBandit;
			if (clan.IsMapFaction) types |= ClanTypes.MapFaction;
			if (clan.IsNoble) types |= ClanTypes.Noble;
			if (clan.IsMinorFaction) types |= ClanTypes.MinorFaction;
			if (clan.IsRebelClan) types |= ClanTypes.Rebel;
			if (clan.IsClanTypeMercenary) types |= ClanTypes.Mercenary;
			if (clan.IsUnderMercenaryService) types |= ClanTypes.UnderMercenaryService;
			if (clan.IsMafia) types |= ClanTypes.Mafia;
			if (clan.IsOutlaw) types |= ClanTypes.Outlaw;
			if (clan.IsNomad) types |= ClanTypes.Nomad;
			if (clan.IsSect) types |= ClanTypes.Sect;
			if (clan.Kingdom == null) types |= ClanTypes.WithoutKingdom;
			if (clan.Heroes.Count == 0) types |= ClanTypes.Empty;
			if (clan == Clan.PlayerClan) types |= ClanTypes.PlayerClan;

			return types;
		}

		/// <summary>
		/// Checks if clan has ALL specified flags
		/// </summary>
		public static bool HasAllTypes(this Clan clan, ClanTypes types)
		{
			if (types == ClanTypes.None) return true;
			var clanTypes = clan.GetClanTypes();
			return (clanTypes & types) == types;
		}

		/// <summary>
		/// Checks if clan has ANY of the specified flags
		/// </summary>
		public static bool HasAnyType(this Clan clan, ClanTypes types)
		{
			if (types == ClanTypes.None) return true;
			var clanTypes = clan.GetClanTypes();
			return (clanTypes & types) != ClanTypes.None;
		}

		/// <summary>
		/// Alias for GetClanTypes to match IEntityExtensions interface
		/// </summary>
		public static ClanTypes GetTypes(this Clan clan) => clan.GetClanTypes();

	#endregion
		#region Clan Tier

		/// <summary>
		/// Set clan tier to a specified tier between 0 and 6
		/// </summary>
		public static bool SetClanTier(this Clan clan, int targetTier)
		{
			// Clan already at target tier
			if (clan.Tier == targetTier)
				return false;

			// Invalid Tier
			if (targetTier < 0 || targetTier > 6)
				return false;

			// Allows clan tier to be lowered
			if (clan.Tier > targetTier)
				clan.ResetClanRenown();

			float requiredRenownForTargetTier = Campaign.Current.Models.ClanTierModel.GetRequiredRenownForTier(targetTier) - clan.Renown;
			clan.AddRenown(requiredRenownForTargetTier);

			return true;
		}

		#endregion

		/// MARK: SetStringName
		/// <summary>
		/// Renames clan using a string instead of TextObject
		/// </summary>
		public static void SetStringName(this Clan clan, string name)
		{
			TextObject nameObj = new(name);
			clan.ChangeClanName(nameObj, nameObj);
		}

		/// Mark: Details and Wrapper
		/// <summary>
		/// Returns a formatted string containing the clan's details
		/// </summary>
		public static string FormattedDetails(this Clan clan)
		{
			return $"{clan.StringId}\t{clan.Name}\tHeroes: {clan.Heroes.Count()}\tLeader: {clan.Leader?.Name}\tKingdom: {clan.Kingdom?.Name}";
		}

	}

	/// <summary>
	/// Wrapper class implementing IEntityExtensions interface for Clan entities
	/// </summary>
	public class ClanExtensionsWrapper : IEntityExtensions<Clan, ClanTypes>
	{
		public ClanTypes GetTypes(Clan entity) => entity.GetClanTypes();
		public bool HasAllTypes(Clan entity, ClanTypes types) => entity.HasAllTypes(types);
		public bool HasAnyType(Clan entity, ClanTypes types) => entity.HasAnyType(types);
		public string FormattedDetails(Clan entity) => entity.FormattedDetails();
	}


}

FILE: ClanGenerator.cs
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Transactions;
using Bannerlord.GameMaster.Banners;
using Bannerlord.GameMaster.Characters;
using Bannerlord.GameMaster.Cultures;
using Bannerlord.GameMaster.Heroes;
using Bannerlord.GameMaster.Information;
using Bannerlord.GameMaster.Party;
using NetworkMessages.FromServer;
using SandBox.GauntletUI.AutoGenerated1;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.Issues;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.Core;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;

namespace Bannerlord.GameMaster.Clans
{
	/// <summary>
	/// Provides functionality for creating and configuring clans with customizable options.
	/// Uses the new HeroGenerator architecture for reliable hero creation.
	/// </summary>
	public static class ClanGenerator
	{
		/// <summary>
		/// Sets the private _midSettlement field on a clan using reflection.
		/// This is necessary to prevent crashes when the game's AI tries to access FactionMidSettlement.
		/// </summary>
		private static void SetClanMidSettlement(Clan clan, Settlement settlement)
		{
			if (clan == null || settlement == null)
				return;

			try
			{
				// Get the private _midSettlement field using reflection
				FieldInfo midSettlementField = typeof(Clan).GetField("_midSettlement", BindingFlags.NonPublic | BindingFlags.Instance);
				
				if (midSettlementField != null)
				{
					midSettlementField.SetValue(clan, settlement);
				}
			}
			catch (System.Exception ex)
			{
				// Log error but don't crash - the clan can still function without mid settlement
				InfoMessage.Warning($"Warning: Failed to set clan mid settlement: {ex.Message}");
			}
		}

		/// MARK: CreateClan
		/// <summary>
		/// Create a new clan with the specified name. The clan will have a party created for its leader filled with troops and companions.<br/>
		/// Optional specify a hero to be moved to the clan and be its leader, defaults to null.
		/// A new hero will be created if hero is null<br/>
		/// Optionally assign clan to kingdom, Kingdom defaults to null (Independent)
		/// </summary>
		/// <param name="name">Name of clan (if null, generates random name from culture)</param>
		/// <param name="leader">Hero to be moved to clan and assigned as it's leader (if null, creates new hero)</param>
		/// <param name="kingdom">Optional: Kingdom to assign clan to, defaults to null (Independent)</param>
		/// <param name="createParty">If true, creates a party for the clan leader (default: true)</param>
		/// <param name="companionCount">Number of companions to add to leader's party (default: 2, 0 to skip)</param>
		/// <param name="cultureFlags">Culture pool for leader creation if leader is null (default: AllMainCultures)</param>
		/// <returns>The created clan</returns>
		public static Clan CreateClan(string name = null, Hero leader = null, Kingdom kingdom = null, bool createParty = true, int companionCount = 2, CultureFlags cultureFlags = CultureFlags.AllMainCultures)
		{
			// Set Temp Id until leader is generated
			string stringId = ObjectManager.Instance.GetUniqueStringId(new("uninitialized"), typeof(Clan));
			Clan clan = Clan.CreateClan(stringId);
			clan.SetStringName(stringId); // Needs a temp name or name lookup crashes

			// Create leader if not provided - clan now exists so CreateLords can use it
			leader ??= HeroGenerator.CreateLords(1, cultureFlags, GenderFlags.Either, clan, withParties: false, randomFactor: 1f)[0];

			// Set actual clan name and Id using the leaders culture after leader was generated
			TextObject nameObj;
			if (name == null)
				nameObj = new(CultureLookup.GetUniqueRandomClanName(leader.Culture));
			else
				nameObj = new(name);
			
			clan.StringId =  ObjectManager.Instance.GetUniqueStringId(nameObj, typeof(Clan));
			clan.ChangeClanName(nameObj, nameObj);

			// Clean up any existing party and settlement state if leader was created elsewhere
			HeroGenerator.CleanupHeroState(leader);

			// Assign leader to clan and configure
			leader.Clan = clan;
			leader.SetNewOccupation(Occupation.Lord);
			leader.IsMinorFactionHero = false;
			clan.SetLeader(leader);
			clan.Culture = leader.Culture;
			clan.BasicTroop = leader.Culture.BasicTroop;
			
			// Create banner and apply unique complementary color scheme
			Banner banner = Banner.CreateRandomClanBanner(RandomNumberGen.Instance.NextRandomInt());
			banner.ApplyUniqueColorScheme();
			clan.Banner = banner;
			clan.Color = banner.GetPrimaryColor();
			clan.Color2 = banner.GetSecondaryColor();

			clan.IsNoble = true;
			clan.IsRebelClan = false;

			// Ensure Clan info is updated
			clan.UpdateFactionsAtWarWith();
			clan.ConsiderAndUpdateHomeSettlement();

			Settlement homeSettlement = leader.GetHomeOrAlternativeSettlement();

			clan.SetInitialHomeSettlement(homeSettlement);
			
			// CRITICAL: Set the mid settlement to prevent crashes when game AI accesses FactionMidSettlement
			// This must be set before clan.Initialize() or when clans join kingdoms
			SetClanMidSettlement(clan, homeSettlement);

			// Create leader's party if requested
			if (createParty && (leader.PartyBelongedTo == null || !leader.IsPartyLeader))
				leader.CreateParty(homeSettlement);

			// Add companions to party if party exists and companions requested
			if (leader.PartyBelongedTo != null && companionCount > 0)
			{
				List<Hero> companions = HeroGenerator.CreateCompanions(companionCount, leader.Culture.ToCultureFlag(), randomFactor: 1);
				leader.PartyBelongedTo.AddCompanionsToParty(companions);
			}

			// Add troops to party if it exists
			if (leader.PartyBelongedTo != null)
			{
				// Add 10 basic, 10 elite, and 10 mercenary troops of the leader's culture
				leader.PartyBelongedTo.AddMixedTierTroops(20);
				leader.PartyBelongedTo.UpgradeTroops();
			}

			// Join Kingdom if specified
			if (kingdom != null)
				ChangeKingdomAction.ApplyByJoinToKingdom(clan, kingdom);

			// Set Clan Tier and related properties
			int targetClanTier = 3;
			clan.SetClanTier(targetClanTier);

			// Gold
			int baseGold = 10000;
			leader.ChangeHeroGold(baseGold * (targetClanTier + 1));

			// Influence
			float baseInfluence = 100;
			clan.Influence += baseInfluence * targetClanTier;
			
			clan.UpdateCurrentStrength();
            clan.Initialize();
			clan.IsReady = true;
			
			return clan;
		}

		/// MARK: GenerateClans
		/// <summary>
		/// Generate multiple clans with random names from culture lists.
		/// Uses the new hero creation architecture to prevent crashes from state conflicts.
		/// </summary>
		/// <param name="count">Number of clans to generate</param>
		/// <param name="cultureFlags">Culture pool to select from (default: AllMainCultures)</param>
		/// <param name="kingdom">Optional kingdom for all clans to join (default: null/Independent)</param>
		/// <param name="createParties">If true, creates parties for clan leaders (default: true)</param>
		/// <param name="companionCount">Number of companions per clan (default: 2)</param>
		/// <returns>List of created clans</returns>
		public static List<Clan> GenerateClans(int count, CultureFlags cultureFlags = CultureFlags.AllMainCultures, Kingdom kingdom = null, bool createParties = true, int companionCount = 2)
		{
			List<Clan> clans = new();
	
			// Create each clan individually, letting CreateClan handle hero creation
			// This ensures each hero is properly initialized with clan association from the start
			for (int i = 0; i < count; i++)
			{
				// Pass null for name and leader to auto-generate
				// CreateClan will create the hero with proper clan association at line 89
				Clan clan = CreateClan(null, null, kingdom, createParties, companionCount, cultureFlags);
				clans.Add(clan);
			}
	
			return clans;
		}

		/// MARK: CreateMinorClan
		/// <summary>
		/// Creates a minor faction clan (not a noble house).
		/// Useful for creating mercenary companies, bandit factions, or other minor groups.
		/// </summary>
		/// <param name="name">Name of the minor clan (if null, generates random name)</param>
		/// <param name="leader">Optional leader hero (creates one if null)</param>
		/// <param name="cultureFlags">Culture for the clan (default: AllMainCultures)</param>
		/// <param name="createParty">If true, creates a party for the leader (default: true)</param>
		/// <returns>The created minor clan</returns>
		public static Clan CreateMinorClan(string name = null, Hero leader = null, CultureFlags cultureFlags = CultureFlags.AllMainCultures, bool createParty = true)
		{
			// Use temp Id until leader is generated
			string stringId = ObjectManager.Instance.GetUniqueStringId(new("uninitialized"), typeof(Clan));
			Clan clan = Clan.CreateClan(stringId);
			clan.SetStringName(stringId); // Needs a temp name or name lookup crashes

			// Create leader if not provided - clan now exists so CreateLords can use it
			if (leader == null)
			{
				leader = HeroGenerator.CreateLords(1, cultureFlags, GenderFlags.Either, clan, withParties: false, randomFactor: 1f)[0];
			}
			else
			{
				HeroGenerator.CleanupHeroState(leader);
			}

			// Generate name if none was provided
			TextObject nameObj;
			if (name == null || name.IsEmpty())
				nameObj = new(CultureLookup.GetUniqueRandomClanName(leader.Culture));
			else
				nameObj = new(name);

			// Set actual clan name and Id using the leaders culture or user provided name, after leader was generated
			clan.StringId =  ObjectManager.Instance.GetUniqueStringId(nameObj, typeof(Clan));
			clan.ChangeClanName(nameObj, nameObj);

			// Update culture from leader in case it changed
			clan.Culture = leader.Culture;
			clan.BasicTroop = leader.Culture.BasicTroop;

			// Assign leader to clan
			leader.Clan = clan;
			leader.SetNewOccupation(Occupation.Lord);
			leader.IsMinorFactionHero = true;  // Mark as minor faction
			clan.SetLeader(leader);
			clan.Banner = Banner.CreateRandomClanBanner(RandomNumberGen.Instance.NextRandomInt());

			clan.IsNoble = false;  // Not a noble clan
			clan.IsRebelClan = false;

			clan.UpdateFactionsAtWarWith();
			clan.ConsiderAndUpdateHomeSettlement();

			Settlement homeSettlement = leader.GetHomeOrAlternativeSettlement();
			clan.SetInitialHomeSettlement(homeSettlement);
			
			// CRITICAL: Set the mid settlement to prevent crashes when game AI accesses FactionMidSettlement
			SetClanMidSettlement(clan, homeSettlement);

			clan.Initialize();

			// Create party if requested
			if (createParty && (leader.PartyBelongedTo == null || !leader.IsPartyLeader))
			{
				leader.CreateParty(homeSettlement);
				
				// Add basic troops
				if (leader.PartyBelongedTo != null)
				{
					leader.PartyBelongedTo.AddBasicTroops(20);
				}
			}

			// Basic properties for minor clan
			clan.SetClanTier(1);
			leader.ChangeHeroGold(5000);
			clan.Influence = 10;

			clan.UpdateCurrentStrength();
			clan.IsReady = true;

			return clan;
		}
	}
}

FILE: ClanQueries.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Party;
using Bannerlord.GameMaster.Common.Interfaces;
using Bannerlord.GameMaster.Console.Common;

namespace Bannerlord.GameMaster.Clans
{
	public static class ClanQueries
    {
        /// <summary>
        /// Finds a clan with the specified clanId, using a case-insensitive comparison.
        /// </summary>
        public static Clan GetClanById(string clanId)
        {
            return Clan.FindFirst(c => c.StringId.Equals(clanId, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Main unified method to find clans by search string and type flags
        /// </summary>
        /// <param name="query">Optional case-insensitive substring to filter by name or ID</param>
        /// <param name="requiredTypes">Clan type flags to match</param>
        /// <param name="matchAll">If true, clan must have ALL flags. If false, clan must have ANY flag</param>
        /// <param name="sortBy">Sort field (id, name, tier, gold, renown, kingdom, or any ClanType flag)</param>
        /// <param name="sortDescending">True for descending, false for ascending</param>
        /// <returns>List of clans matching all criteria</returns>
        public static List<Clan> QueryClans(
            string query = "",
            ClanTypes requiredTypes = ClanTypes.None,
            bool matchAll = true,
            string sortBy = "id",
            bool sortDescending = false)
        {
            IEnumerable<Clan> clans = Clan.All;

            // Filter by name/ID if provided
            if (!string.IsNullOrEmpty(query))
            {
                string lowerFilter = query.ToLower();
                clans = clans.Where(c =>
                    c.Name.ToString().ToLower().Contains(lowerFilter) ||
                    c.StringId.ToLower().Contains(lowerFilter));
            }

            // Filter by clan types
            if (requiredTypes != ClanTypes.None)
            {
                clans = clans.Where(c => matchAll ? c.HasAllTypes(requiredTypes) : c.HasAnyType(requiredTypes));
            }

            // Apply sorting
            clans = ApplySorting(clans, sortBy, sortDescending);

            return clans.ToList();
        }

        /// <summary>
        /// Apply sorting to clans collection
        /// </summary>
        private static IEnumerable<Clan> ApplySorting(
            IEnumerable<Clan> clans,
            string sortBy,
            bool descending)
        {
            sortBy = sortBy.ToLower();

            // Check if sortBy matches a ClanType flag
            if (Enum.TryParse<ClanTypes>(sortBy, true, out var clanType) && clanType != ClanTypes.None)
            {
                // Sort by whether clan has this type flag
                return descending
                    ? clans.OrderByDescending(c => c.GetClanTypes().HasFlag(clanType))
                    : clans.OrderBy(c => c.GetClanTypes().HasFlag(clanType));
            }

            // Sort by standard fields
            IOrderedEnumerable<Clan> orderedClans = sortBy switch
            {
                "name" => descending
                    ? clans.OrderByDescending(c => c.Name.ToString())
                    : clans.OrderBy(c => c.Name.ToString()),
                "tier" => descending
                    ? clans.OrderByDescending(c => c.Tier)
                    : clans.OrderBy(c => c.Tier),
                "gold" => descending
                    ? clans.OrderByDescending(c => c.Gold)
                    : clans.OrderBy(c => c.Gold),
                "renown" => descending
                    ? clans.OrderByDescending(c => c.Renown)
                    : clans.OrderBy(c => c.Renown),
                "kingdom" => descending
                    ? clans.OrderByDescending(c => c.Kingdom?.Name?.ToString() ?? "")
                    : clans.OrderBy(c => c.Kingdom?.Name?.ToString() ?? ""),
                "heroes" => descending
                    ? clans.OrderByDescending(c => c.Heroes.Count)
                    : clans.OrderBy(c => c.Heroes.Count),
                _ => descending  // default to id
                    ? clans.OrderByDescending(c => c.StringId)
                    : clans.OrderBy(c => c.StringId)
            };

            return orderedClans;
        }

        /// <summary>
        /// Parse a string into ClanTypes enum value
        /// </summary>
        public static ClanTypes ParseClanType(string typeString)
        {
            // Handle special cases and aliases
            var normalizedType = typeString.ToLower() switch
            {
                "active" => "Active",
                "eliminated" => "Eliminated",
                "bandit" => "Bandit",
                "nonbandit" => "NonBandit",
                "mapfaction" => "MapFaction",
                "noble" => "Noble",
                "minor" => "MinorFaction",
                "minorfaction" => "MinorFaction",
                "rebel" => "Rebel",
                "mercenary" => "Mercenary",
                "merc" => "Mercenary",
                "undermercenaryservice" => "UnderMercenaryService",
                "mafia" => "Mafia",
                "outlaw" => "Outlaw",
                "nomad" => "Nomad",
                "sect" => "Sect",
                "withoutkingdom" => "WithoutKingdom",
                "empty" => "Empty",
                "player" => "PlayerClan",
                "playerclan" => "PlayerClan",
                _ => typeString
            };

            if (Enum.TryParse<ClanTypes>(normalizedType, true, out var result))
                return result;
            return ClanTypes.None;
        }

        /// <summary>
        /// Parse multiple strings and combine into ClanTypes flags
        /// </summary>
        public static ClanTypes ParseClanTypes(IEnumerable<string> typeStrings)
        {
            ClanTypes combined = ClanTypes.None;
            foreach (var typeString in typeStrings)
            {
                var parsed = ParseClanType(typeString);
                if (parsed != ClanTypes.None)
                    combined |= parsed;
            }
            return combined;
        }

        /// <summary>
        /// Returns a formatted string listing clan details with aligned columns
        /// </summary>
        public static string GetFormattedDetails(List<Clan> clans)
        {
        	if (clans.Count == 0)
        		return "";
      
        	return ColumnFormatter<Clan>.FormatList(
        		clans,
        		c => c.StringId,
        		c => c.Name.ToString(),
        		c => $"Culture: {c.Culture?.Name?.ToString() ?? "None"}",
        		c => $"Heroes: {c.Heroes.Count()}",
        		c => $"Leader: {c.Leader?.Name?.ToString() ?? "None"}",
        		c => $"Kingdom: {c.Kingdom?.Name?.ToString() ?? "None"}"
        	);
        }

        /// <summary>
        /// Get all party leaders for a specific clan
        /// </summary>
        public static List<Hero> GetPartyLeaders(Clan clan)
        {
            return MobileParty.All
                .Where(p => p.LeaderHero != null && p.LeaderHero.Clan == clan)
                .Select(p => p.LeaderHero)
                .ToList();
        }
 }

 /// <summary>
 /// Wrapper class implementing IEntityQueries interface for Clan entities
 /// </summary>
 public class ClanQueriesWrapper : IEntityQueries<Clan, ClanTypes>
 {
  public Clan GetById(string id) => ClanQueries.GetClanById(id);
  public List<Clan> Query(string query, ClanTypes types, bool matchAll) => ClanQueries.QueryClans(query, types, matchAll);
  public ClanTypes ParseType(string typeString) => ClanQueries.ParseClanType(typeString);
  public ClanTypes ParseTypes(IEnumerable<string> typeStrings) => ClanQueries.ParseClanTypes(typeStrings);
  public string GetFormattedDetails(List<Clan> entities) => ClanQueries.GetFormattedDetails(entities);
 }
}
FILE: IEntityExtensions.cs
using System;

namespace Bannerlord.GameMaster.Common.Interfaces
{
	public interface IEntityExtensions<TEntity, TTypes> 
		where TTypes : struct, Enum
	{
		TTypes GetTypes(TEntity entity);
		bool HasAllTypes(TEntity entity, TTypes types);
		bool HasAnyType(TEntity entity, TTypes types);
		string FormattedDetails(TEntity entity);
	}
}
FILE: IEntityQueries.cs
using System;
using System.Collections.Generic;

namespace Bannerlord.GameMaster.Common.Interfaces
{
	public interface IEntityQueries<TEntity, TTypes> 
		where TTypes : struct, Enum
	{
		TEntity GetById(string id);
		List<TEntity> Query(string query, TTypes types, bool matchAll);
		TTypes ParseType(string typeString);
		TTypes ParseTypes(IEnumerable<string> typeStrings);
		string GetFormattedDetails(List<TEntity> entities);
	}
}
FILE: CultureExtensions.cs
using TaleWorlds.CampaignSystem;

namespace Bannerlord.GameMaster.Cultures
{
    public static class CultureExtensions
    {
        /// <summary>
        /// Gets the CultureFlag enum value that corresponds to this culture object.
        /// </summary>
        /// <param name="culture">The culture object to convert.</param>
        /// <returns>The corresponding CultureFlag value, or CultureFlags.None if not found or null.</returns>
        public static CultureFlags ToCultureFlag(this CultureObject culture)
        {
            return CultureLookup.GetCultureFlag(culture);
        }
    }
}

FILE: CultureFlags.cs
using System;

namespace Bannerlord.GameMaster.Cultures
{
    [Flags]
    public enum CultureFlags
    {
        None = 0,

        // Main Cultures (bits 0-7)
        Calradian = 1 << 0, 
        Aserai = 1 << 1,    
        Battania = 1 << 2,  
        Empire = 1 << 3,    
        Khuzait = 1 << 4,   
        Nord = 1 << 5,      
        Sturgia = 1 << 6,   
        Vlandia = 1 << 7,   
        AllMainCultures = Calradian | Aserai | Battania | Empire |
                          Khuzait | Nord | Sturgia | Vlandia,

        // Bandit Cultures (bits 8-14)
        Looters = 1 << 8,         
        DesertBandits = 1 << 9,   
        ForestBandits = 1 << 10,  
        MountainBandits = 1 << 11,
        SteppeBandits = 1 << 12,  
        SeaRaiders = 1 << 13,     
        Corsairs = 1 << 14,       
        AllBanditCultures = Looters | DesertBandits | ForestBandits |
                            MountainBandits | SteppeBandits | SeaRaiders | Corsairs,

        // Special Cultures (bits 15-16)
        DarshiSpecial = 1 << 15,
        VakkenSpecial = 1 << 16,

        // All combinations
        AllCultures = AllMainCultures | AllBanditCultures |
                      DarshiSpecial | VakkenSpecial
    }
}
FILE: CultureLookup.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using TaleWorlds.ObjectSystem;
using TaleWorlds.Localization;

namespace Bannerlord.GameMaster.Cultures
{
	public static class CultureLookup
	{
		/// MARK: Culture Lookup
		public static CultureObject Aserai => MBObjectManager.Instance.GetObject<CultureObject>("aserai");
		public static CultureObject Battania => MBObjectManager.Instance.GetObject<CultureObject>("battania");
		public static CultureObject Empire => MBObjectManager.Instance.GetObject<CultureObject>("empire");
		public static CultureObject Khuzait => MBObjectManager.Instance.GetObject<CultureObject>("khuzait");
		public static CultureObject Nord => MBObjectManager.Instance.GetObject<CultureObject>("nord");
		public static CultureObject Sturgia => MBObjectManager.Instance.GetObject<CultureObject>("sturgia");
		public static CultureObject Vlandia => MBObjectManager.Instance.GetObject<CultureObject>("vlandia");

		public static CultureObject DesertBandits => MBObjectManager.Instance.GetObject<CultureObject>("desert_bandits");
		public static CultureObject ForestBandits => MBObjectManager.Instance.GetObject<CultureObject>("forest_bandits");
		public static CultureObject Looters => MBObjectManager.Instance.GetObject<CultureObject>("looters");
		public static CultureObject MountainBandits => MBObjectManager.Instance.GetObject<CultureObject>("mountain_bandits");
		public static CultureObject SeaRaiders => MBObjectManager.Instance.GetObject<CultureObject>("sea_raiders");
		public static CultureObject Corsairs => MBObjectManager.Instance.GetObject<CultureObject>("southern_pirates");
		public static CultureObject SteppeBandits => MBObjectManager.Instance.GetObject<CultureObject>("steppe_bandits");

		public static CultureObject DarshiSpecial => MBObjectManager.Instance.GetObject<CultureObject>("darshi");
		public static CultureObject VakkenSpecial => MBObjectManager.Instance.GetObject<CultureObject>("vakken");

		public static CultureObject CalradianNeutral => MBObjectManager.Instance.GetObject<CultureObject>("neutral_culture");

		public static List<CultureObject> AllCultures => MBObjectManager.Instance.GetObjectTypeList<CultureObject>();

		public static List<CultureObject> MainCultures
		{
			get
			{
				List<CultureObject> _mainCultures = new();
				foreach (CultureObject culture in AllCultures)
				{
					if (culture.IsMainCulture)
						_mainCultures.Add(culture);
				}

				return _mainCultures;
			}
		}

		public static List<CultureObject> BanditCultures
		{
			get
			{
				List<CultureObject> _banditCultures = new();
				foreach (CultureObject culture in AllCultures)
				{
					if (culture.IsBandit)
						_banditCultures.Add(culture);
				}

				return _banditCultures;
			}
		}

		/// MARK: Hero Name
		/// <summary>
		/// Gets a random hero name from the culture's gender-specific name list.
		/// First tries native game names, then custom names, then adds a suffix if all are exhausted.
		/// </summary>
		public static string GetUniqueRandomHeroName(CultureObject culture, bool isFemale)
		{
			// Get all existing hero names (convert to strings for comparison)
			HashSet<string> existingHeroNames = Hero.AllAliveHeroes
			 .Select(h => h.FirstName?.ToString() ?? string.Empty)
			 .Where(name => !string.IsNullOrEmpty(name))
			 .ToHashSet(StringComparer.OrdinalIgnoreCase);

			// Try native game name list first
			List<TextObject> cultureNameList = isFemale
			 ? culture.FemaleNameList.ToList()
			 : culture.MaleNameList.ToList();

			List<TextObject> availableNativeNames = cultureNameList
			 .Where(nameObj => !existingHeroNames.Contains(nameObj.ToString()))
			 .ToList();

			if (availableNativeNames.Count > 0)
			{
				int randomIndex = RandomNumberGen.Instance.NextRandomInt(availableNativeNames.Count);
				return availableNativeNames[randomIndex].ToString();
			}

			// Try custom name list if native names are exhausted
			string cultureId = culture.StringId.ToLower();
			Dictionary<string, List<string>> customNameDict = isFemale ? CustomNames.FemaleHeroNames : CustomNames.MaleHeroNames;

			if (customNameDict.TryGetValue(cultureId, out List<string> customNames))
			{
				List<string> availableCustomNames = customNames
				 .Where(name => !existingHeroNames.Contains(name))
				 .ToList();

				if (availableCustomNames.Count > 0)
				{
					int randomIndex = RandomNumberGen.Instance.NextRandomInt(availableCustomNames.Count);
					return availableCustomNames[randomIndex];
				}
			}

			// All names exhausted - add a suffix to a random name
			string[] suffixes = {
	"the Younger", "the Elder", "the Brave", "the Wise",
	"the Bold", "the Just", "the Swift", "the Strong",
	"the Fierce", "the Noble", "the Fair", "the Valiant"
   };

			// Try to use custom names first for suffix, then fall back to native
			string baseName;
			if (customNameDict.TryGetValue(cultureId, out List<string> customNamesForSuffix) && customNamesForSuffix.Count > 0)
			{
				int randomNameIndex = RandomNumberGen.Instance.NextRandomInt(customNamesForSuffix.Count);
				baseName = customNamesForSuffix[randomNameIndex];
			}
			
			else if (cultureNameList.Count > 0)
			{
				int randomNameIndex = RandomNumberGen.Instance.NextRandomInt(cultureNameList.Count);
				baseName = cultureNameList[randomNameIndex].ToString();
			}

			else
			{
				// Last resort fallback
				baseName = isFemale ? "Hero" : "Warrior";
			}

			int randomSuffixIndex = RandomNumberGen.Instance.NextRandomInt(suffixes.Length);
			return $"{baseName} {suffixes[randomSuffixIndex]}";
		}

		/// MARK: Clan Name
		/// <summary>
		/// Gets a random clan name from the culture's clan name list.
		/// First tries native game names, then custom names, then adds a suffix if all are exhausted.
		/// </summary>
		public static string GetUniqueRandomClanName(CultureObject culture)
		{
			// Get all existing clan names (convert to strings for comparison)
			HashSet<string> existingClanNames = Clan.All
				.Select(c => c.Name.ToString())
				.ToHashSet(StringComparer.OrdinalIgnoreCase);

			// Try native game clan name list first
			List<TextObject> availableNativeNames = culture.ClanNameList
				.Where(nameObj => !existingClanNames.Contains(nameObj.ToString()))
				.ToList();

			if (availableNativeNames.Count > 0)
			{
				int randomIndex = RandomNumberGen.Instance.NextRandomInt(availableNativeNames.Count);
				return availableNativeNames[randomIndex].ToString();
			}

			// Try custom clan name list if native names are exhausted
			string cultureId = culture.StringId.ToLower();

			if (CustomNames.ClanNames.TryGetValue(cultureId, out List<string> customNames))
			{
				List<string> availableCustomNames = customNames
					.Where(name => !existingClanNames.Contains(name))
					.ToList();

				if (availableCustomNames.Count > 0)
				{
					int randomIndex = RandomNumberGen.Instance.NextRandomInt(availableCustomNames.Count);
					return availableCustomNames[randomIndex];
				}
			}

			// All names exhausted - add a suffix to a random name
			string[] suffixes = {
				"of The New World", "Separatists", "Loyalists", "Conservatives",
				"of Calradia", "New Order", "Exiles", "Wanderers",
				"Reborn", "Rising", "Ascendant", "Defiant"
			};

			// Try to use custom names first for suffix, then fall back to native
			string baseName;
			if (CustomNames.ClanNames.TryGetValue(cultureId, out List<string> customNamesForSuffix) && customNamesForSuffix.Count > 0)
			{
				int randomNameIndex = RandomNumberGen.Instance.NextRandomInt(customNamesForSuffix.Count);
				baseName = customNamesForSuffix[randomNameIndex];
			}

			else if (culture.ClanNameList.Count > 0)
			{
				int randomNameIndex = RandomNumberGen.Instance.NextRandomInt(culture.ClanNameList.Count);
				baseName = culture.ClanNameList[randomNameIndex].ToString();
			}

			else
			{
				// Last resort fallback
				baseName = "Clan";
			}

			int randomSuffixIndex = RandomNumberGen.Instance.NextRandomInt(suffixes.Length);
			return $"{baseName} {suffixes[randomSuffixIndex]}";
		}

		/// MARK: Kingdom Name
		/// <summary>
		/// Gets a random kingdom name appropriate to the specified culture.
		/// First tries custom names, then adds a suffix if all are exhausted.
		/// </summary>
		public static string GetUniqueRandomKingdomName(CultureObject culture)
		{
			// Get all existing kingdom names (convert to strings for comparison)
			HashSet<string> existingKingdomNames = Kingdom.All
				.Select(k => k.Name.ToString())
				.ToHashSet(StringComparer.OrdinalIgnoreCase);

			// Try custom kingdom name list
			string cultureId = culture.StringId.ToLower();

			if (CustomNames.KingdomNames.TryGetValue(cultureId, out List<string> customNames))
			{
				List<string> availableCustomNames = customNames
					.Where(name => !existingKingdomNames.Contains(name))
					.ToList();

				if (availableCustomNames.Count > 0)
				{
					int randomIndex = RandomNumberGen.Instance.NextRandomInt(availableCustomNames.Count);
					return availableCustomNames[randomIndex];
				}
			}

			// All names exhausted - add a suffix to a random name
			string[] suffixes = {
				"Reborn", "Rising", "Ascendant", "Renewed",
				"Reformed", "Restored", "United", "Free",
				"New Order", "Resurgent", "Revived", "Triumphant"
			};

			// Try to use custom names first for suffix
			string baseName;
			if (CustomNames.KingdomNames.TryGetValue(cultureId, out List<string> customNamesForSuffix) && customNamesForSuffix.Count > 0)
			{
				int randomNameIndex = RandomNumberGen.Instance.NextRandomInt(customNamesForSuffix.Count);
				baseName = customNamesForSuffix[randomNameIndex];
			}
			else
			{
				// Last resort fallback
				baseName = $"{culture.Name} Kingdom";
			}

			int randomSuffixIndex = RandomNumberGen.Instance.NextRandomInt(suffixes.Length);
			return $"{baseName} {suffixes[randomSuffixIndex]}";
		}

		/// MARK: Culture Flags
		/// <summary>
		/// Gets the CultureFlag enum value that corresponds to the provided culture object.
		/// </summary>
		/// <param name="culture">The culture object to convert.</param>
		/// <returns>The corresponding CultureFlag value, or CultureFlags.None if not found or null.</returns>
		public static CultureFlags GetCultureFlag(CultureObject culture)
		{
			if (culture == null)
				return CultureFlags.None;

			return culture.StringId.ToLower() switch
			{
				"neutral_culture" => CultureFlags.Calradian,
				"aserai" => CultureFlags.Aserai,
				"battania" => CultureFlags.Battania,
				"empire" => CultureFlags.Empire,
				"khuzait" => CultureFlags.Khuzait,
				"nord" => CultureFlags.Nord,
				"sturgia" => CultureFlags.Sturgia,
				"vlandia" => CultureFlags.Vlandia,
				"looters" => CultureFlags.Looters,
				"desert_bandits" => CultureFlags.DesertBandits,
				"forest_bandits" => CultureFlags.ForestBandits,
				"mountain_bandits" => CultureFlags.MountainBandits,
				"steppe_bandits" => CultureFlags.SteppeBandits,
				"sea_raiders" => CultureFlags.SeaRaiders,
				"southern_pirates" => CultureFlags.Corsairs,
				"darshi" => CultureFlags.DarshiSpecial,
				"vakken" => CultureFlags.VakkenSpecial,
				_ => CultureFlags.None
			};
		}
	}
}
FILE: CustomNames.cs
using System.Collections.Generic;

namespace Bannerlord.GameMaster.Cultures
{
    /// <summary>
    /// Custom names representing each culture for clans and heroes
    /// </summary>
    public static class CustomNames
    {
        /// <summary>
        /// Cultural Male Hero Names
        /// </summary>
        public static readonly Dictionary<string, List<string>> MaleHeroNames = new Dictionary<string, List<string>>
    {
        /// MARK: Aserai - Male
        ["aserai"] = new List<string>
            {
                // Original set
                "Azhar", "Basir", "Darim", "Faisal", "Habib", "Jalal", "Kamal", "Malik",
                "Nadir", "Qadir", "Rashid", "Salim", "Tariq", "Walid", "Yazid", "Zafar",
                "Bahir", "Fahd", "Hakim", "Idris", "Kamil", "Latif", "Munir", "Nasir",
                "Rami", "Saif", "Talib", "Yasir", "Zahir", "Akram", "Bashir", "Fadil",
                // Additional powerful names
                "Asad", "Badr", "Dawud", "Faris", "Ghalib", "Hamza", "Jabir", "Khalid",
                "Majid", "Nasser", "Omar", "Qasim", "Rayyan", "Saqr", "Thabit", "Umar",
                "Waleed", "Yahya", "Zaki", "Abbas", "Bilal", "Harun", "Jafar", "Kadir",
                "Luqman", "Marwan", "Nabil", "Qutaiba", "Rafiq", "Shams", "Usman", "Wasim",
                "Ammar", "Basim", "Daud", "Farouk", "Ghazi", "Hadi", "Isa", "Jamil",
                "Kareem", "Mahdi", "Naeem", "Rayan", "Sadiq", "Tahir", "Yasin", "Zaid",
                "Adil", "Burhan", "Danish", "Fadl", "Hashim", "Ibrahim", "Jamal", "Karam",
                "Mansur", "Nabeel", "Rauf", "Sami", "Tariq", "Wali", "Yusuf", "Zaheer",
                "Amir", "Bakr", "Dinar", "Fahim", "Ghaith", "Husam", "Jawad", "Kasim"
            },
        /// MARK: Battania - Male
        ["battania"] = new List<string>
            {
                // Original set
                "Bran", "Cael", "Donal", "Eamon", "Fergus", "Gareth", "Hugh", "Ivar",
                "Kevan", "Loran", "Moran", "Niall", "Owen", "Piran", "Ronan", "Senan",
                "Torvin", "Ulric", "Varen", "Wren", "Alwyn", "Bevan", "Cormac", "Damon",
                "Edan", "Finn", "Gavin", "Iain", "Kael", "Lonan", "Merlin", "Nolan",
                // Additional Celtic/Gaelic names
                "Aiden", "Blair", "Connor", "Declan", "Erwin", "Finian", "Griffin", "Hagan",
                "Kellen", "Logan", "Maddox", "Nolan", "Oran", "Patrick", "Quinn", "Rory",
                "Shane", "Teague", "Vaughn", "Warren", "Brennan", "Conan", "Donovan", "Ewan",
                "Galvin", "Hogan", "Kieran", "Liam", "Morgan", "Neil", "Osgar", "Padraig",
                "Rowan", "Sean", "Tiernan", "Ultan", "Aengus", "Brion", "Caolan", "Diarmuid",
                "Fiachra", "Gethin", "Idris", "Kian", "Lorcan", "Murtagh", "Odhran", "Phelan",
                "Riordan", "Soren", "Tadhg", "Urien", "Albin", "Brogan", "Cadoc", "Drustan",
                "Emrys", "Fyfe", "Gruffydd", "Hugh", "Iolyn", "Kendrick", "Llewyn", "Madoc",
                "Nial", "Owain", "Pedr", "Rhys", "Sayer", "Taliesin", "Uilleam", "Wulfric"
            },
        /// MARK: Empire - Male
        ["empire"] = new List<string>
            {
                // Original set (reduced -os endings)
                "Agron", "Castos", "Daron", "Evron", "Gaius", "Heron", "Juron", "Kyros",
                "Marius", "Nero", "Orion", "Petros", "Quron", "Seron", "Titus", "Veron",
                "Aeron", "Beron", "Ceron", "Denos", "Euros", "Geros", "Horos", "Janos",
                "Keros", "Lenos", "Meros", "Noros", "Poros", "Renos", "Soros", "Teros",
                // More variety - Roman/Greek mix with different endings
                "Adrian", "Brutus", "Caesar", "Darius", "Flavius", "Hadrian", "Julius", "Lucian",
                "Marcus", "Aurelius", "Octavian", "Primus", "Quintus", "Remus", "Scipio", "Trajan",
                "Valerian", "Augustus", "Corvus", "Drusus", "Felix", "Gallus", "Horatius", "Magnus",
                "Maximus", "Severus", "Tacitus", "Victor", "Antonius", "Cassius", "Decimus", "Gaius",
                "Lucius", "Appius", "Balbus", "Claudius", "Demetrius", "Erasmus", "Fabius", "Gregorius",
                "Hektor", "Justus", "Konstantinos", "Leonidas", "Marcellus", "Nikias", "Octavius", "Paulus",
                "Quintilian", "Regulus", "Septimus", "Tiberius", "Valentinus", "Alexios", "Basileios", "Chrysanthos",
                "Dion", "Eugenios", "Fotios", "Gavriil", "Herakles", "Iason", "Kosmas", "Lycurgus",
                "Makarios", "Nestor", "Odysseus", "Philippos", "Romanos", "Stephanos", "Theodoros", "Vasilis"
            },
        /// MARK: Khuzait - Male
        ["khuzait"] = new List<string>
            {
                // Original set
                "Baatar", "Chagan", "Dagan", "Erdene", "Ganbat", "Hulagu", "Jebe", "Kublai",
                "Mongke", "Nogai", "Orda", "Qasar", "Subotai", "Temuge", "Ulaanbar", "Yesugei",
                "Arban", "Batu", "Chagatai", "Genghis", "Hadan", "Jochi", "Kadan", "Munglik",
                "Nayan", "Ogodai", "Sorgan", "Tumen", "Ulagan", "Bayan", "Chilaun", "Dorbei",
                // Additional Mongol/Turkic names
                "Altan", "Bataar", "Chingis", "Dorji", "Erden", "Galdan", "Hulan", "Jibek",
                "Khulan", "Ligdan", "Mongol", "Naiman", "Ogedei", "Qutlugh", "Temur", "Uighur",
                "Yeke", "Altai", "Borte", "Chahar", "Duwa", "Esen", "Guyuk", "Hulegu",
                "Jagatai", "Khubilai", "Mangu", "Negudar", "Oirat", "Qaidu", "Rashid", "Sanjar",
                "Toghrul", "Uzbeg", "Baidar", "Chaghri", "Danishmend", "Eljigidei", "Ghazan", "Hulun",
                "Jani", "Kaidu", "Manggala", "Nogai", "Osman", "Qazan", "Sartak", "Turakina",
                "Ulus", "Berkut", "Cagan", "Delger", "Erke", "Ganzorig", "Haraqan", "Irgen",
                "Jelme", "Khadan", "Manlai", "Naranbaatar", "Otgon", "Purevdorj", "Sengge", "Targan",
                "Ulziit", "Bolor", "Chimeg", "Davaajav", "Enkhbayar", "Gansukh", "Khenbish", "Monkhbat"
            },
        /// MARK: Nord - Male
        ["nord"] = new List<string>
            {
                // Original set
                "Bjorn", "Dag", "Erik", "Finn", "Gunnar", "Harald", "Ivar", "Knut",
                "Leif", "Magnus", "Olaf", "Ragnar", "Sigurd", "Thorin", "Ulf", "Vidar",
                "Alrik", "Balder", "Egil", "Frode", "Grimr", "Halvard", "Jorund", "Ketil",
                "Orm", "Rolf", "Sven", "Torsten", "Ulf", "Varg", "Yngve", "Arngeir",
                // Additional Norse/Nordic names
                "Asbjorn", "Bjarni", "Einar", "Finn", "Gorm", "Hakon", "Ingvar", "Jorgen",
                "Kjartan", "Leifr", "Magni", "Njal", "Ove", "Ragnvald", "Sigvald", "Thorfinn",
                "Ulfric", "Viggo", "Arn", "Bard", "Eyvind", "Grim", "Hjalmar", "Isak",
                "Jarl", "Kol", "Lars", "Magne", "Njord", "Orn", "Roald", "Sture",
                "Thrand", "Ulf", "Vali", "Aslak", "Bergthor", "Einar", "Folke", "Gunnar",
                "Hrolf", "Ingolf", "Kjell", "Leif", "Mogens", "Nils", "Oskar", "Roar",
                "Skarde", "Thorfinn", "Ulrik", "Vigleik", "Asgeir", "Bragi", "Egill", "Floki",
                "Gudmund", "Havard", "Ivarr", "Kare", "Lodinn", "Modolf", "Nori", "Ottar",
                "Ravn", "Styrkar", "Tormod", "Vagn", "Aki", "Bodvar", "Eilif", "Geir"
            },
        /// MARK: Sturgia - Male
        ["sturgia"] = new List<string>
            {
                // Original set
                "Bogdan", "Dmitri", "Gregor", "Igor", "Kazimir", "Lazar", "Miro", "Nikolai",
                "Pavel", "Radoslav", "Stefan", "Tomislav", "Vadim", "Yuri", "Zlatan", "Boris",
                "Dragomir", "Goran", "Ivan", "Jaroslav", "Konstantin", "Leonid", "Milos", "Oleg",
                "Petar", "Roman", "Stanislav", "Timur", "Viktor", "Zoran", "Anatoly", "Bronislav",
                // Additional Slavic names
                "Alexei", "Branko", "Davor", "Emil", "Filip", "Gavril", "Hrvoje", "Ivo",
                "Jovan", "Kiril", "Luka", "Marko", "Nedeljko", "Ognjen", "Pavle", "Radomir",
                "Svyatoslav", "Taras", "Uros", "Velimir", "Andrei", "Borislav", "Danilo", "Evgeni",
                "Georgi", "Hristo", "Ilija", "Josip", "Kosta", "Ljubomir", "Milan", "Niko",
                "Ostoja", "Predrag", "Rajko", "Slobodan", "Teodor", "Vasilij", "Aleksandar", "Bojan",
                "Dusan", "Ervin", "Goran", "HrvojÐµ", "Ivica", "Janko", "Kresimir", "Lubomir",
                "Matej", "Nemanja", "Oleksandr", "Perica", "Ratko", "Srdjan", "Toma", "Vladislav",
                "Yaroslav", "Anto", "Blazenko", "Dalibor", "Emir", "Franjo", "Gradimir", "Hrvoj",
                "Ilija", "Jago", "Krunoslav", "Ljudevit", "Miljenko", "Nikola", "Ozren", "Prvoslav"
            },
        /// MARK: Vlandia - Male
        ["vlandia"] = new List<string>
            {
                // Original set
                "Aldric", "Bertrand", "Conrad", "Drogo", "Edmund", "Fulk", "Geoffrey", "Hugh",
                "Ingmar", "Jocelyn", "Lambert", "Milo", "Norbert", "Odo", "Philip", "Rainald",
                "Sigmund", "Thierry", "Ulrich", "Valeran", "Warin", "Baldwin", "Clovis", "Dreux",
                "Eustace", "Godfrey", "Hector", "Ives", "Leon", "Manfred", "Otto", "Reynard",
                // Additional medieval European names
                "Albert", "Bernard", "Charles", "Denis", "Edgar", "Frederick", "Gunther", "Henry",
                "Ingram", "Jordan", "Kurt", "Louis", "Martin", "Nicolas", "Oswald", "Peter",
                "Quentin", "Richard", "Stephen", "Thomas", "Urban", "Victor", "Walter", "Alaric",
                "Bruno", "Clement", "Dietrich", "Everard", "Felix", "Gerard", "Hartmann", "Ivo",
                "Jerome", "Karl", "Ludwig", "Maurice", "Normann", "Osric", "Paulus", "Raimond",
                "Siegfried", "Thibault", "Ugo", "Volkmar", "Wilhelm", "Arnulf", "Baldric", "Cedric",
                "Dankwart", "Egbert", "Folcard", "Gislebert", "Hartwig", "Isembard", "Jaufre", "Konrad",
                "Ludovic", "Mallory", "Norvin", "Obert", "Percival", "Roland", "Sigurd", "Theodoric",
                "Ulwin", "Valdemar", "Werner", "Adalbert", "Bodo", "Childebert", "Dietmar", "Ernst"
            }
    };

        /// <summary>
        /// Female hero names for each culture
        /// </summary>
        public static readonly Dictionary<string, List<string>> FemaleHeroNames = new Dictionary<string, List<string>>
    {
        /// MARK: Aserai - Female
        ["aserai"] = new List<string>
            {
                // Original set
                "Amira", "Basma", "Dalila", "Farah", "Habiba", "Jalila", "Karima", "Layla",
                "Muna", "Nadia", "Rania", "Safiya", "Tahira", "Yasmin", "Zahra", "Amina",
                "Fatima", "Halima", "Jamila", "Khadija", "Latifa", "Malika", "Naima", "Rasha",
                "Samira", "Tamara", "Wafaa", "Yasmina", "Zainab", "Aziza", "Bahira", "Farida",
                // Additional powerful names
                "Aisha", "Bushra", "Dunya", "Fadila", "Ghada", "Hana", "Iman", "Jamilah",
                "Kalila", "Leila", "Mariam", "Nada", "Qadira", "Rima", "Salma", "Thurayya",
                "Warda", "Yara", "Zaynab", "Almas", "Bahija", "Dima", "Faiza", "Hiba",
                "Inas", "Jumana", "Kamila", "Lubna", "Maysa", "Noor", "Rabia", "Samar",
                "Tala", "Widad", "Zahirah", "Anisa", "Basira", "Duha", "Fatin", "Hala",
                "Ibtisam", "Jalwa", "Kanza", "Lamya", "Maysoon", "Najwa", "Rashida", "Shadha",
                "Thuraya", "Wafa", "Yamna", "Zahra", "Ameera", "Badia", "Dalal", "Fawzia",
                "Hessa", "Izzah", "Janan", "Karima", "Lina", "Maha", "Najma", "Rawiya",
                "Sumaya", "Thana", "Wijdan", "Asma", "Budur", "Dalia", "Fikriyya", "Halah"
            },
        /// MARK: Battania - Female
        ["battania"] = new List<string>
            {
                // Original set
                "Aife", "Brigid", "Cara", "Deirdre", "Eira", "Fiona", "Gwen", "Isolde",
                "Keira", "Lianna", "Maeve", "Nessa", "Rhona", "Seren", "Tara", "Una",
                "Alys", "Brenna", "Ceri", "Eilidh", "Ffion", "Grania", "Isla", "Morna",
                "Niamh", "Oona", "Rhiannon", "Siobhan", "Teagan", "Vanya", "Aisling", "Bronwen",
                // Additional Celtic/Gaelic names
                "Aoife", "Branwen", "Ciara", "Dervla", "Enid", "Fionnuala", "Grainne", "Iona",
                "Keelin", "Lorna", "Mairead", "Neve", "Orla", "Rhian", "Shannon", "Treasa",
                "Ula", "Ailsa", "Brianna", "Clodagh", "Delaney", "Eithne", "Fionnula", "Gwyneth",
                "Imogen", "Kyla", "Lowri", "Meredith", "Nuala", "Oonagh", "Rowena", "Sinead",
                "Tamsin", "Wynne", "Aislinn", "Briony", "Catriona", "Dwyn", "Eleri", "Faye",
                "Glenna", "Isolda", "Kiera", "Lynwen", "Moira", "Nerys", "Olwen", "Rhosyn",
                "Sorcha", "Tegwen", "Una", "Aerona", "Blair", "Carrigan", "Deryn", "Elen",
                "Fallon", "Gwenda", "Iona", "Keara", "Lynet", "Morgan", "Neala", "Owena",
                "Rhianna", "Saoirse", "Tamara", "Valerie", "Ailbhe", "Briana", "Caitlin", "Dearbhla"
            },
        /// MARK: Empire - Female
        ["empire"] = new List<string>
            {
                // Original set (more variety added)
                "Aelia", "Cassia", "Diana", "Elena", "Flora", "Helena", "Iris", "Julia",
                "Lucia", "Marina", "Nora", "Olivia", "Petra", "Rhea", "Silvia", "Thalia",
                "Aurelia", "Camilla", "Delia", "Fabia", "Gaia", "Lydia", "Marcella", "Portia",
                "Sabina", "Valeria", "Acacia", "Cora", "Felicia", "Livia", "Octavia", "Vera",
                // Additional with more variety (not all ending in -a)
                "Antonia", "Claudia", "Drusilla", "Flavia", "Hortensia", "Junia", "Lavinia", "Marcia",
                "Paulina", "Sulpicia", "Tullia", "Agrippina", "Caecilia", "Domitia", "Faustina", "Galeria",
                "Lepida", "Metella", "Pompeia", "Scribonia", "Terentia", "Vipsania", "Aemilia", "Cornelia",
                "Fulvia", "Livia", "Messalina", "Plautia", "Servilia", "Vibia", "Anastasia", "Corina",
                "Eugenia", "Irene", "Melina", "Sophia", "Theodora", "Zoe", "Berenice", "Daphne",
                "Eudoxia", "Galene", "Hypatia", "Kalliope", "Lysandra", "Myrina", "Nike", "Olympia",
                "Phoebe", "Roxana", "Selene", "Thalassa", "Xanthe", "Althea", "Basilia", "Charis",
                "Dione", "Electra", "Galen", "Hero", "Ianthe", "Kassandra", "Larissa", "Melia",
                "Nephele", "Pelagia", "Sibyl", "Thais", "Zenobia", "Ariadne", "Clio", "Eurydice"
            },
        /// MARK: Khuzait - Female
        ["khuzait"] = new List<string>
            {
                // Original set
                "Altani", "Bolormaa", "Chagaan", "Enkhtuya", "Gerel", "Khongor", "Mandukhai", "Naran",
                "Oyuun", "Saran", "Temulun", "Ulaana", "Yesui", "Altantsetseg", "Battsetseg", "Enkhjin",
                "Ganbaatar", "Khulan", "Munkhtsetseg", "Narangerel", "Odtsetseg", "Sarangerel", "Tsogt", "Tuul",
                "Uyanga", "Chimge", "Delger", "Erdenechimeg", "Javkhlan", "Narantsetseg", "Otgonbayar", "Tuvshinbayar",
                // Additional Mongol/Turkic names with more variety
                "Anar", "Bayarmaa", "Cholmon", "Dalaijargal", "Erdene", "Ganbold", "Hoelun", "Idugan",
                "Jendu", "Khutulun", "Lhamaa", "Mandal", "Narantsetseg", "Oghul", "Qutlugh", "Sorkhaqtani",
                "Toregene", "Ulagan", "Yesugei", "Altun", "Bayarma", "Checheyigen", "Dagmar", "Erdeni",
                "Gunjin", "Hulun", "Jochi", "Khatun", "Lkhagva", "Munkhzaya", "Narantuyaa", "Odval",
                "Purev", "Sarnai", "Tsetseg", "Uranchimeg", "Yesuntai", "Ariunaa", "Bolormaa", "Ceceg",
                "Delgermaa", "Enkhmaa", "Gantsetseg", "Horolmaa", "Ider", "Jargal", "Kherlen", "Lhagva",
                "Monkhtsetseg", "Nergui", "Odonchimeg", "Purevsuren", "Sainaa", "Tsolmon", "Uranzaya", "Yesugen",
                "Altan", "Bayar", "Chimeg", "Davaajargal", "Enkhbayar", "Ganzul", "Hulan", "Jargalsaikhan",
                "Khaliun", "Lkhagvadorj", "Munkhbayar", "Narantuya", "Oyunbileg", "Purevdorj", "Saran", "Tsagaan"
            },
        /// MARK: Nord - Female
        ["nord"] = new List<string>
            {
                // Original set
                "Asa", "Brynhild", "Dagny", "Eira", "Freya", "Gudrun", "Hilda", "Ingrid",
                "Jorunn", "Kari", "Liv", "Magna", "Ragna", "Sigrid", "Thora", "Ulfhild",
                "Astrid", "Bodil", "Eldrid", "Frida", "Gerd", "Helga", "Karin", "Signe",
                "Solveig", "Tove", "Vigdis", "Ylva", "Arna", "Bergthora", "Dalla", "Gunnhild",
                // Additional Norse/Nordic names
                "Alfhild", "Bergljot", "Dagmar", "Elin", "Freja", "Gyda", "Hjordis", "Ingibjorg",
                "Jorunn", "Katla", "Linnea", "Maren", "Nanna", "Ragnhild", "Sigrun", "Thorhild",
                "Unn", "Valdis", "Alfrida", "Bothild", "Embla", "Freyja", "Gunhild", "Hertha",
                "Inga", "Kelda", "Lagertha", "Mjoll", "Nerthus", "Randi", "Sigyn", "Thyra",
                "Urd", "Valgerd", "Asdis", "Brenna", "Eira", "Fjola", "Gro", "Hrefna",
                "Idunn", "Jarla", "Kjolvor", "Lilja", "Minna", "Oddny", "Revna", "Svala",
                "Thordis", "Una", "Viga", "Asgerd", "Bera", "Drifa", "Eydis", "Frida",
                "Gunnvor", "Halla", "Idun", "Jorunn", "Kolbrun", "Laufey", "Monika", "Nanna",
                "Oda", "Rannveig", "Saga", "Thorunn", "Unna", "Vigga", "Alva", "Bergthora"
            },
        /// MARK: Sturgia - Female
        ["sturgia"] = new List<string>
            {
                // Original set
                "Alina", "Bogdana", "Daria", "Elena", "Galina", "Irina", "Katya", "Lada",
                "Milena", "Nadia", "Olga", "Rada", "Svetlana", "Tatyana", "Vera", "Yana",
                "Anastasia", "Darinka", "Elina", "Gordana", "Ivana", "Ljuba", "Marina", "Natasha",
                "Radomira", "Stanislava", "Tanya", "Vesna", "Zora", "Agnessa", "Draga", "Ludmila",
                // Additional Slavic names
                "Anja", "Branka", "Danka", "Emilija", "Faina", "Galena", "Hristina", "Iskra",
                "Jelena", "Katica", "Larisa", "Maja", "Nadiya", "Olena", "Polina", "Roksana",
                "Sonja", "Tanja", "Valentina", "Yelena", "Zlata", "Aleksandra", "Biljana", "Daniela",
                "Elizabeta", "Gabriela", "Hana", "Ivanka", "Jasna", "Koviljka", "Ludmilla", "Marija",
                "Natalija", "Olivera", "Pavlina", "Rajna", "Snezana", "Tamara", "Varvara", "Anushka",
                "Borislava", "Danica", "Ekaterina", "Feodora", "Grozda", "Hripsima", "Ilinca", "Juliana",
                "Kristina", "Lyudmila", "Miroslava", "Nikola", "Oksana", "Radmila", "Sofiya", "Tatiana",
                "Ulyana", "Vladislava", "Yelizaveta", "Antonina", "Bozena", "Dobromira", "Evgeniya", "Galina",
                "Hristina", "Inga", "Jaroslava", "Krystyna", "Liliya", "Milica", "Nevena", "Oxana"
            },
        /// MARK: Vlandia - Female
        ["vlandia"] = new List<string>
            {
                // Original set
                "Adelaide", "Beatrice", "Constance", "Eleanor", "Giselle", "Hildegard", "Isolde", "Matilda",
                "Rosamund", "Sybilla", "Agnes", "Blanche", "Cecilia", "Edith", "Genevieve", "Heloise",
                "Isabelle", "Margery", "Philippa", "Richilda", "Alicia", "Bertha", "Clarisse", "Emma",
                "Fleur", "Gwendolyn", "Jeanne", "Leonora", "Mabel", "Odette", "Rosalind", "Yvette",
                // Additional medieval European names
                "Adela", "Brunhilde", "Catherine", "Diane", "Ermengarde", "Felicity", "Gertrude", "Hedwig",
                "Ida", "Judith", "Katherine", "Leticia", "Margaret", "Nicole", "Olive", "Petronilla",
                "Rosaline", "Sophia", "Theodora", "Ursula", "Victoria", "Winifred", "Alice", "Brigitta",
                "Charlotte", "Dorothy", "Elizabeth", "Florence", "Geraldine", "Henrietta", "Ingrid", "Joanna",
                "Leonore", "Magdalena", "Nicolette", "Ottilia", "Prudence", "Rosemary", "Scholastica", "Teresa",
                "Ulrica", "Veronica", "Wilhelmina", "Amelia", "Brigitte", "Cordelia", "Desiree", "Estelle",
                "Gabrielle", "Helene", "Josephine", "Lucille", "Madeline", "Natalie", "Ophelia", "Pauline",
                "Simone", "Therese", "Vivienne", "Annette", "Bernadette", "Colette", "Danielle", "Eloise",
                "Francoise", "Georgette", "Henriette", "Juliette", "Lisette", "Marceline", "Ninette", "Paulette"
            }
    };

        /// <summary>
        /// Cultural Clan Names for each Culture
        /// </summary>
        public static readonly Dictionary<string, List<string>> ClanNames = new Dictionary<string, List<string>>
    {
        /// MARK: Aserai - Clan
        ["aserai"] = new List<string>
            {
                // Original set
                "Banu Harith", "Banu Rashid", "Banu Malik", "Banu Faisal", "Banu Yazid", "Banu Azhar",
                "Banu Nasir", "Banu Walid", "Banu Kamal", "Banu Jalal", "Banu Tariq", "Banu Salim",
                "Banu Zahir", "Banu Hakim", "Banu Idris", "Banu Munir", "Banu Bashir", "Banu Saif",
                "Banu Rami", "Banu Akram", "Banu Fadil", "Banu Latif", "Banu Qadir", "Banu Habib",
                // Additional clans
                "Banu Khalid", "Banu Hamza", "Banu Jafar", "Banu Omar", "Banu Rayyan", "Banu Shams",
                "Banu Thabit", "Banu Umar", "Banu Wasim", "Banu Yasin", "Banu Abbas", "Banu Dawud",
                "Banu Ghazi", "Banu Hadi", "Banu Isa", "Banu Jamil", "Banu Kareem", "Banu Mahdi",
                "Banu Nabil", "Banu Qasim", "Banu Sadiq", "Banu Tahir", "Banu Waleed", "Banu Zaid",
                "Banu Adil", "Banu Burhan", "Banu Dinar", "Banu Fahd", "Banu Ghaith", "Banu Husam",
                "Banu Jawad", "Banu Karam", "Banu Mansur", "Banu Nabeel", "Banu Rauf", "Banu Sami"
            },
        /// MARK: Battania - Clan
        ["battania"] = new List<string>
            {
                // Original set
                "fen Brennan", "fen Cormac", "fen Donnell", "fen Ewan", "fen Garvan", "fen Kelan",
                "fen Lorcan", "fen Murtagh", "fen Niall", "fen Rowan", "fen Seanan", "fen Tiernan",
                "fen Aidan", "fen Cian", "fen Finnian", "fen Kieran", "fen Oran", "fen Tadhg",
                "fen Brogan", "fen Declan", "fen Fionn", "fen Liam", "fen Padraig", "fen Ronan",
                // Additional clans
                "fen Connor", "fen Diarmuid", "fen Ewan", "fen Griffin", "fen Hugh", "fen Kellen",
                "fen Logan", "fen Maddox", "fen Neil", "fen Osgar", "fen Patrick", "fen Quinn",
                "fen Rory", "fen Shane", "fen Teague", "fen Ultan", "fen Vaughn", "fen Warren",
                "fen Aengus", "fen Brion", "fen Conan", "fen Donovan", "fen Fiachra", "fen Galvin",
                "fen Hogan", "fen Kian", "fen Murtagh", "fen Odhran", "fen Phelan", "fen Riordan",
                "fen Soren", "fen Torvin", "fen Ulric", "fen Albin", "fen Cadoc", "fen Drustan"
            },
        /// MARK: Empire - Clan
        ["empire"] = new List<string>
            {
                // Original set (with more variety)
                "Aelios", "Castorios", "Delanos", "Euronos", "Garonios", "Heronos", "Jurios", "Kyronos",
                "Leorios", "Menios", "Neranos", "Oronios", "Petrios", "Qunios", "Seranos", "Tironos",
                "Aronios", "Benios", "Carios", "Denios", "Ferios", "Garios", "Herios", "Janios",
                "Karios", "Lenios", "Morios", "Norios", "Porios", "Renios", "Serios", "Torios",
                // Additional with variety (mixing Roman and Greek styles)
                "Antonius", "Bruticus", "Claudius", "Drusus", "Flavianus", "Gracchus", "Horatius", "Junius",
                "Lucanus", "Marcellus", "Octavius", "Quintus", "Rufus", "Severus", "Valerius", "Aquillius",
                "Cornelius", "Domitius", "Fabius", "Gallus", "Livius", "Metellus", "Pompeius", "Scipio",
                "Basileus", "Chrysos", "Demetrios", "Euphrates", "Gregorios", "Herakles", "Ionicus", "Konstantinos",
                "Leonidas", "Makedon", "Nikephoros", "Olympios", "Philippos", "Romanos", "Stephanos", "Theodosius"
            },
        /// MARK: Khuzait - Clan
        ["khuzait"] = new List<string>
            {
                // Original set
                "Baratai", "Chagait", "Dorbenait", "Ergit", "Genghait", "Hulait", "Jebeit", "Kubait",
                "Manglait", "Nogait", "Ordait", "Qarait", "Subait", "Temuit", "Ulaait", "Yesait",
                "Arbait", "Batuit", "Chilait", "Dorbait", "Ganait", "Hadait", "Jochit", "Kadait",
                "Mongait", "Nayanit", "Ogait", "Sorgait", "Tumait", "Ulagait", "Bayanit", "Dolonait",
                // Additional clans
                "Altanit", "Batuit", "Chaghait", "Duwaait", "Esenait", "Guyukait", "Hulunit", "Jagataait",
                "Khubilait", "Ligdanit", "Manggait", "Negudait", "Oiratait", "Qaiduit", "Rashidait", "Sanjarait",
                "Toghrulit", "Uzbegait", "Baidarit", "Chaghriit", "Danishmendait", "Eljigideait", "Ghazanait", "Hulunait",
                "Janibegait", "Kaiduit", "Manggalait", "Nogaijit", "Osmanait", "Qazanit", "Sartakait", "Turakinait",
                "Ulusait", "Berkutait", "Caganait", "Delgerait", "Erkeait", "Ganzorait", "Haraqanait", "Irgenait"
            },
        /// MARK: Nord - Clan
        ["nord"] = new List<string>
            {
                // Original set
                "Bjorning", "Dagring", "Eriking", "Finnring", "Gunnaring", "Haraldring", "Ivaring", "Knutring",
                "Leifing", "Magnusing", "Olafring", "Ragnaring", "Sigurdring", "Thorring", "Ulfring", "Vidaring",
                "Alriking", "Baldring", "Egilring", "Frodering", "Grimring", "Halvarding", "Jorundring", "Ketilring",
                "Ormring", "Rolfring", "Svenring", "Torstering", "Vargring", "Yngvering", "Arnring", "Bodring",
                // Additional clans
                "Asbjorning", "Bjarniring", "Einarring", "Finnuring", "Gormring", "Hakonring", "Ingvarring", "Jorgenring",
                "Kjartanring", "Leifrring", "Magniring", "Njalring", "Overing", "Ragnvaldring", "Sigvaldring", "Thorfinnring",
                "Ulfricring", "Viggoring", "Arnring", "Bardring", "Eyvindring", "Grimring", "Hjalmarring", "Isakring",
                "Jarlring", "Kolring", "Larsring", "Magnering", "Njordring", "Ornring", "Roaldring", "Sturering",
                "Thrandring", "Ulfring", "Valiring", "Asgeiring", "Braging", "Eilifring", "Flokiring", "Geirring"
            },
        /// MARK: Sturgia - Clan
        ["sturgia"] = new List<string>
            {
                // Original set
                "Bogdanoving", "Dmitroving", "Gregoroving", "Igoroving", "Kaziroving", "Lazaroving", "Miroving", "Nikoloving",
                "Paveloving", "Radoving", "Stefanoving", "Tomioving", "Vadimoving", "Yurioving", "Zlatoving", "Borisoving",
                "Dragoving", "Goranoving", "Ivanoving", "Jaroving", "Konstantoving", "Leonoving", "Milosoving", "Olegoving",
                "Petroving", "Romanoving", "Stanisloving", "Timuroving", "Viktoroving", "Zoranoving", "Anatoloving", "Bronioving",
                // Additional clans
                "Alexeioving", "Brankoving", "Davoroving", "Emiloving", "Filipoving", "Gavriloving", "Hrvojeoving", "Ivoving",
                "Jovanoving", "Kiriloving", "Lukaroving", "Markoving", "Nedeljkoving", "Ognjenoving", "Pavleoving", "Radomiroving",
                "Svyatosloving", "Tarasoving", "Urosoving", "Velimiroving", "Andreioving", "Borislavoving", "Daniloving", "Evgenioving",
                "Georgioving", "Hristoving", "Ilijaroving", "Josipoving", "Kostaroving", "Ljubomiroving", "Milanoving", "Nikoving",
                "Ostojaroving", "Predragoving", "Rajkoving", "Slobodanoving", "Teodoroving", "Vasilijoving", "Aleksandroving", "Bojanoving"
            },
        /// MARK: Vlandia - Clan
        ["vlandia"] = new List<string>
            {
                // Original set
                "dey Aldren", "dey Bertrand", "dey Conran", "dey Drogan", "dey Edmund", "dey Fulken", "dey Geoffren",
                "dey Huguard", "dey Ingmar", "dey Jocelen", "dey Lambard", "dey Miloran", "dey Norben", "dey Odon",
                "dey Philen", "dey Rainalden", "dey Sigmund", "dey Thieren", "dey Ulrichen", "dey Valeran", "dey Warine",
                "dey Baldric", "dey Cloven", "dey Dreugen", "dey Eustacen", "dey Godfren", "dey Hectoren", "dey Leonard",
                // Additional clans
                "dey Alberten", "dey Bernarden", "dey Charlen", "dey Denisen", "dey Edgaren", "dey Frederiken", "dey Guntheren",
                "dey Henrien", "dey Ingramen", "dey Jordanen", "dey Kurten", "dey Louisen", "dey Martinen", "dey Nicolasen",
                "dey Oswalden", "dey Peteren", "dey Quentinen", "dey Richarden", "dey Stephenen", "dey Thomasen", "dey Urbanen",
                "dey Victoren", "dey Walteren", "dey Alaricen", "dey Brunoen", "dey Clementen", "dey Dietrichen", "dey Everarden",
                "dey Felixen", "dey Gerarden", "dey Hartmannen", "dey Jeromen", "dey Karlen", "dey Ludwigen", "dey Mauricen"
            }
    };

        /// <summary>
        /// Cultural Kingdom Names for each Culture
        /// </summary>
        public static readonly Dictionary<string, List<string>> KingdomNames = new Dictionary<string, List<string>>
    {
        /// MARK: Aserai - Kingdom
        ["aserai"] = new List<string>
            {
                "Sultanate of Al-Qamar", "Sultanate of Al-Rashid", "Sultanate of Al-Azhar",
                "Sultanate of Al-Zahir", "Sultanate of Al-Walid", "Sultanate of Al-Nasir",
                "Sultanate of Al-Saif", "Sultanate of Al-Qadir", "Sultanate of Al-Basir",
                "Caliphate of Qahira", "Caliphate of Zafran", "Caliphate of Nurabad",
                "Caliphate of Saraqand", "Caliphate of Al-Malik", "Caliphate of Al-Kamal",
                "Emirate of Najirah", "Emirate of Khazara", "Emirate of Zahrat",
                "Sultanate of Bahar", "Emirate of Rashidun", "Kingdom of Kharasan",
                "Kingdom of Saharan", "Kingdom of Malukar", "Sultanate of Asadabad",
                "Emirate of Faridun", "Kingdom of Tarikia", "Sultanate of Ghaziran",
                "Caliphate of Harithia", "Kingdom of Samarra", "Sultanate of Jazira",
                "Kingdom of Qasiria", "Emirate of Nasirabad", "Caliphate of Zahirabad"
            },
        /// MARK: Battania - Kingdom
        ["battania"] = new List<string>
            {
                "Kingdom of Riata", "Kingdom of Gwyneth", "Kingdom of Connath",
                "Kingdom of Munstir", "Kingdom of Ulsara", "Kingdom of Leinora",
                "Kingdom of Strathlyn", "Kingdom of Powyr", "Kingdom of Dyfan",
                "Kingdom of Albion", "Kingdom of Deharan", "Kingdom of Rhegan",
                "Kingdom of Elmar", "Kingdom of Gododor", "Kingdom of Pictaran",
                "Brigantia", "Icenara", "Catuvelara",
                "Confederacy of Albarn", "Caledor", "Hibernian Kingdom",
                "United Gaeldom", "Cornovara", "Gwentor",
                "Morgannor", "Brychanor", "Ceredigarn",
                "Kingdom of Meathan", "Desmonar", "Thomonar",
                "High Kingdom of Eriana", "Pictland", "Kingdom of Mannar"
            },
        /// MARK: Empire - Kingdom
        ["empire"] = new List<string>
            {
                "New Empire of Calradia", "United Empire of Nicara", "Empire of Trebizon",
                "Despotate of Epiron", "Despotate of Morean", "Republic of Dobruna",
                "Kingdom of Macedoria", "Pontian Kingdom", "Kingdom of Bithara",
                "New Empire of Komnenora", "United Empire of Palaeon", "Empire of Angeloran",
                "Thracian Kingdom", "Kingdom of Thessalan", "Republic of Cypron",
                "Exarchate of Ravenos", "Province of Anatolon", "Province of Thrakeon",
                "Despotate of Mystron", "Principality of Acharan", "Duchy of Athenora",
                "Eastern Empire", "Western Empire", "Northern Empire",
                "Kingdom of Pergamon", "Kingdom of Armenos", "Republic of Iberon",
                "Praetorian Prefecture", "Senatorial Republic", "Imperial Province",
                "New Tetrarchy", "United Pentarchy", "Calradian Empire"
            },
        /// MARK: Khuzait - Kingdom
        ["khuzait"] = new List<string>
            {
                "Khanate of the Golden Horde", "Khanate of the White Horde", "Khanate of the Blue Horde",
                "Chagataran Khanate", "Ilkhara Khanate", "Great Yuanese Dynasty",
                "Khanate of Khivara", "Khanate of Bukhar", "Khanate of Kokandan",
                "Xiongun Empire", "Rouran Empire", "Gokturan Khaganate",
                "Uyguran Khaganate", "Khazaran Khaganate", "Avaran Khaganate",
                "Scytharan Empire", "Sarmatian Kingdom", "Hunnic Empire",
                "Crimean Khanate", "Kazaran Khanate", "Astrakhan Khanate",
                "Sibiran Khanate", "Nogaran Horde", "Kazakhan Khanate",
                "Dzungaran Khanate", "Qaran Khanate", "Timuran Empire",
                "Seljukan Empire", "Sultanate of Rumara", "Cumanian Khanate",
                "Pechenoran Khanate", "Kipchakan Confederation", "Mongolaran Empire"
            },
        /// MARK: Nord - Kingdom
        ["nord"] = new List<string>
            {
                "Nordland", "Danemark", "Swedenor",
                "Kingdom of Upsalar", "Kingdom of Vestfaldor", "Hordalor",
                "Jarldom of Orkenor", "Kingdom of the Islar", "Dublinor",
                "Jorvikar", "Northumbran Kingdom", "East Angloran Kingdom",
                "Principality of Novgaror", "Principality of Polotskara", "Gardarikian Kingdom",
                "Iselandor", "Earldom of Ladaran", "Kingdom of Ringeran",
                "Agderan Kingdom", "Rogalor", "Trondelar",
                "Kingdom of Jamtlor", "Gotaland", "Svealor",
                "Jarldom of Hallaran", "Skaneland", "Bornholmar",
                "Gotlandor", "Kingdom of the Danskaran", "Kingdom of the Geatar",
                "Jarldom of Hedmaran", "Vingulmar", "North Sea Kingdom"
            },
        /// MARK: Sturgia - Kingdom
        ["sturgia"] = new List<string>
            {
                "Principality of Novgarod", "Principality of Kievan", "Principality of Vladaran",
                "Grand Principality of Moskovar", "Principality of Suzdalor", "Principality of Ryazaran",
                "Principality of Chernor", "Principality of Smolenskan", "Principality of Polotskara",
                "Principality of Turovara", "Principality of Pereyar", "Principality of Halycharan",
                "Kingdom of Galician", "Tsardom of Bulgaran", "Tsardom of Serbian",
                "Kingdom of Croatan", "Kingdom of Bosnian", "Serbian Empire",
                "Despotate of Serban", "Kingdom of Rascian", "Banate of Bosnaran",
                "Principality of Tverian", "Principality of Yaroslavan", "Principality of Rostovan",
                "Grand Duchy of Lithoran", "Kingdom of Polaran", "Kievan Dominion",
                "Principality of Pskovara", "Principality of Muroman", "Principality of Beloran",
                "Tsardom of Russkar", "United Empire of Russar", "Kingdom of Ruthoran"
            },
        /// MARK: Vlandia - Kingdom
        ["vlandia"] = new List<string>
            {
                "Kingdom of Francor", "Kingdom of Burgundar", "Kingdom of Lotharor",
                "Kingdom of Arlesian", "Kingdom of Provencan", "Kingdom of Aquitaran",
                "Duchy of Normandor", "Duchy of Brittaran", "County of Flanderon",
                "County of Champaran", "Duchy of Gasconar", "Kingdom of Navarran",
                "Kingdom of Aragonar", "Kingdom of Castilian", "Kingdom of Leonar",
                "Kingdom of Germaran", "Kingdom of Italaran", "Kingdom of Bohemaran",
                "Duchy of Bavaran", "Duchy of Swabar", "Duchy of Saxonor",
                "County of Hollandar", "County of Hainautar", "Duchy of Brabantor",
                "Kingdom of Angland", "Kingdom of Scotaran", "Principality of Walesor",
                "Holy Calradian Empire", "Latinian Empire", "Kingdom of Jerusalemar",
                "County of Toulousar", "Duchy of Lorranar", "Margraviate of Brandenor"
            }
    };
    }
}
FILE: HeroExtensions.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.CampaignSystem.Party.PartyComponents;
using TaleWorlds.CampaignSystem.Settlements;
using SandBox.Issues;
using TaleWorlds.Localization;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.Core;

namespace Bannerlord.GameMaster.Heroes
{
	#region Flags / Types

	[Flags]
	public enum HeroTypes
	{
		None = 0,
		IsArtisan = 1,
		Lord = 2,
		Wanderer = 4,
		Notable = 8,
		Merchant = 16, Children = 32,
		Female = 64,
		Male = 128,
		ClanLeader = 256,
		KingdomRuler = 512,
		PartyLeader = 1024,
		Fugitive = 2048,
		Alive = 4096,
		Dead = 8192,
		Prisoner = 16384,
		WithoutClan = 32768,
		WithoutKingdom = 65536,
		Married = 131072,
	}

	public static class HeroExtensions
	{
		/// <summary>
		/// Gets all hero type flags for this hero
		/// </summary>
		public static HeroTypes GetHeroTypes(this Hero hero)
		{
			HeroTypes types = HeroTypes.None;

			if (hero.IsArtisan) types |= HeroTypes.IsArtisan;
			if (hero.IsLord) types |= HeroTypes.Lord;
			if (hero.IsWanderer) types |= HeroTypes.Wanderer;
			if (hero.IsNotable) types |= HeroTypes.Notable;
			if (hero.IsMerchant) types |= HeroTypes.Merchant;
			if (hero.IsChild) types |= HeroTypes.Children;
			if (hero.IsFemale) types |= HeroTypes.Female;
			if (!hero.IsFemale) types |= HeroTypes.Male;
			if (hero.Clan?.Leader == hero) types |= HeroTypes.ClanLeader;
			if (hero.Clan?.Kingdom?.Leader == hero) types |= HeroTypes.KingdomRuler;
			if (hero.PartyBelongedTo?.LeaderHero == hero) types |= HeroTypes.PartyLeader;
			if (hero.IsFugitive) types |= HeroTypes.Fugitive;
			if (hero.IsAlive) types |= HeroTypes.Alive;
			if (!hero.IsAlive) types |= HeroTypes.Dead;
			if (hero.IsPrisoner) types |= HeroTypes.Prisoner;
			if (hero.Clan == null) types |= HeroTypes.WithoutClan;
			if (hero.Clan?.Kingdom == null) types |= HeroTypes.WithoutKingdom;
			if (hero.Spouse != null) types |= HeroTypes.Married;

			return types;
		}

		/// <summary>
		/// Checks if hero has ALL specified flags
		/// </summary>
		public static bool HasAllTypes(this Hero hero, HeroTypes types)
		{
			if (types == HeroTypes.None) return true;
			var heroTypes = hero.GetHeroTypes();
			return (heroTypes & types) == types;
		}

		/// <summary>
		/// Checks if hero has ANY of the specified flags
		/// </summary>
		public static bool HasAnyType(this Hero hero, HeroTypes types)
		{
			if (types == HeroTypes.None) return true;
			var heroTypes = hero.GetHeroTypes();
			return (heroTypes & types) != HeroTypes.None;
		}

		/// <summary>
		/// Alias for GetHeroTypes to match IEntityExtensions interface
		/// </summary>
		public static HeroTypes GetTypes(this Hero hero) => hero.GetHeroTypes();

		#endregion
		#region Party

		/// <summary>
		/// Creates a party, and configuring AI to work as a normal party.<br/>
		/// Party is initalized with 20000 trade gold and 10 basic troops
		/// </summary>
		/// <param name="hero"></param>
		/// <param name="spawnSettlement"></param>
		/// <returns></returns>
		public static MobileParty CreateParty(this Hero hero, Settlement spawnSettlement)
		{
			MobileParty party = LordPartyComponent.CreateLordParty(
			stringId: "party_" + hero.StringId,
			hero: hero,
			position: spawnSettlement.GatePosition,
			spawnRadius: 0.5f,
			spawnSettlement: spawnSettlement,
			partyLeader: hero
			);

			party.DesiredAiNavigationType = MobileParty.NavigationType.All;
			party.Aggressiveness = Math.Max(0.3f, RandomNumberGen.Instance.NextRandomFloat());
			party.PartyTradeGold = 20000;
			//party.PartyMoveMode = MoveModeType.Party; // For caravans?

			//party.InitializeMobilePartyAtPosition(hero.Clan.DefaultPartyTemplate, spawnSettlement.GatePosition);
			party.AddElementToMemberRoster(hero.Culture.BasicTroop, 10);
			party.Ai.EnableAi();
			party.SetMovePatrolAroundSettlement(spawnSettlement, party.DesiredAiNavigationType, false);

			return party;
		}

		#endregion
		#region Settlement

		/// <summary>
		/// Returns the Hero's home settlement if not null, otherwise grabs a random settlement in this order: <br/>
		/// Home Settlement > Random Clan Owned Settlement > Random Kingdom Owned Settlement > Random Settlement
		/// </summary>
		public static Settlement GetHomeOrAlternativeSettlement(this Hero hero)
		{
			//Prefer actual home settlement
			if (hero.HomeSettlement != null)
				return hero.HomeSettlement;

			Settlement alternativeSettlement;

			// Try to get Clan Settlement first
				if (hero.Clan != null && hero.Clan.Settlements != null && hero.Clan.Settlements.Count > 0)
					alternativeSettlement = hero.Clan.Settlements.FindAll(s => s.IsTown).GetRandomElement();

			// If no Clan Settlments, Try kingdom
			else if (hero.Clan != null && hero.Clan.Kingdom != null && hero.Clan.Kingdom.Settlements != null && hero.Clan.Kingdom.Settlements.Count > 0)
				alternativeSettlement = hero.Clan.Kingdom.Settlements.FindAll(s => s.IsTown).GetRandomElement();

			// Fallback to any settlement if no clan or kingdom settlements found
			else
				alternativeSettlement = Settlement.All.FindAll(s => s.IsTown).GetRandomElement();

			return alternativeSettlement;
		}

		#endregion
		#region Equipment

		/// <summary>
		/// Equips hero with random pieces of different elite troop equipment based on hero's culture
		/// </summary>
		public static void EquipHeroBasedOnCulture(this Hero hero)
		{
			// Get a random high-tier troop from hero's culture for battle equipment
			var cultureTroops = CharacterObject.All
				.Where(c => c.Culture == hero.Culture
							&& c.IsSoldier
							&& !c.IsHero
							&& c.Tier >= 4  // Tier 4+ troops (elite)
							&& c.Equipment != null
							&& !c.Equipment[EquipmentIndex.Weapon0].IsEmpty)
				.ToList();

			if (cultureTroops.Count > 0)
			{
				var randomTroop = cultureTroops[RandomNumberGen.Instance.NextRandomInt(cultureTroops.Count)];
				hero.BattleEquipment.FillFrom(randomTroop.Equipment);
			}

			// Civilian equipment from culture roster
			var civilianRoster = hero.Culture.DefaultCivilianEquipmentRoster;
			if (civilianRoster != null && civilianRoster.AllEquipments.Count > 0)
			{
				int civilianIndex = RandomNumberGen.Instance.NextRandomInt(civilianRoster.AllEquipments.Count);
				hero.CivilianEquipment.FillFrom(civilianRoster.AllEquipments[civilianIndex]);
			}
		}

		/// <summary>
		/// Equips hero with random different pieces of gear from a pool of existing lords and high tier troops based on gender and culture of hero
		/// </summary>
		/// <param name="hero"></param>
		public static void EquipLordBasedOnCulture(this Hero hero)
		{
			// Gather equipment pool from lords and elite troops (same culture AND gender)
			var equipmentSources = new List<Equipment>();

			// Add equipment from lords (best quality) - same culture AND gender
			var cultureLords = Hero.AllAliveHeroes
				.Where(h => h.Culture == hero.Culture
							&& h.IsFemale == hero.IsFemale  // Same gender
							&& h.IsLord
							&& h != hero
							&& h.BattleEquipment != null)
				.Take(20);  // Limit to avoid performance issues

			foreach (var lord in cultureLords)
			{
				if (!lord.BattleEquipment[EquipmentIndex.Weapon0].IsEmpty)
					equipmentSources.Add(lord.BattleEquipment);
			}

			// Add equipment from tier 5 troops (elite quality) - same culture AND gender
			var eliteTroops = CharacterObject.All
				.Where(c => c.Culture == hero.Culture
							&& c.IsFemale == hero.IsFemale  // Same gender
							&& c.IsSoldier
							&& !c.IsHero
							&& c.Tier >= 5
							&& c.Equipment != null
							&& !c.Equipment[EquipmentIndex.Weapon0].IsEmpty)
				.Take(20);

			foreach (var troop in eliteTroops)
			{
				equipmentSources.Add(troop.Equipment);
			}

			// Build randomized battle equipment by mixing pieces
			if (equipmentSources.Count > 0)
			{
				for (int i = 0; i < 12; i++)  // All equipment slots
				{
					var randomSource = equipmentSources[RandomNumberGen.Instance.NextRandomInt(equipmentSources.Count)];
					var equipmentElement = randomSource[i];

					if (!equipmentElement.IsEmpty)
						hero.BattleEquipment[i] = equipmentElement;
				}
			}

			// Civilian equipment - mix from lords' civilian equipment (same gender)
			var civilianSources = cultureLords
				.Where(l => l.CivilianEquipment != null && !l.CivilianEquipment[EquipmentIndex.Body].IsEmpty)
				.Select(l => l.CivilianEquipment)
				.ToList();

			if (civilianSources.Count > 0)
			{
				for (int i = 0; i < 12; i++)
				{
					var randomSource = civilianSources[RandomNumberGen.Instance.NextRandomInt(civilianSources.Count)];
					var equipmentElement = randomSource[i];

					if (!equipmentElement.IsEmpty)
						hero.CivilianEquipment[i] = equipmentElement;
				}
			}
			else
			{
				// Fallback to culture civilian roster
				var civilianRoster = hero.Culture.DefaultCivilianEquipmentRoster;
				if (civilianRoster != null && civilianRoster.AllEquipments.Count > 0)
				{
					int civilianIndex = RandomNumberGen.Instance.NextRandomInt(civilianRoster.AllEquipments.Count);
					hero.CivilianEquipment.FillFrom(civilianRoster.AllEquipments[civilianIndex]);
				}
			}
		}
		#endregion
		#region Name / Details

		/// <summary>
		/// Set heroes name using a string instead of TextObject
		/// </summary>
		public static void SetStringName(this Hero hero, string name)
		{
			TextObject nameObj = new(name);
			hero.SetName(nameObj, nameObj);
		}

		/// <summary>
		/// Returns a formatted string containing the hero's details
		/// </summary>
		public static string FormattedDetails(this Hero hero)
		{
			return $"{hero.StringId}\t{hero.Name}\tCulture: {hero.Culture?.Name}\tClan: {hero.Clan?.Name}\tKingdom: {hero.Clan?.Kingdom?.Name}";
		}
		
		#endregion
	}

	/// <summary>
	/// Wrapper class implementing IEntityExtensions interface for Hero entities
	/// </summary>
	public class HeroExtensionsWrapper : IEntityExtensions<Hero, HeroTypes>
	{
		public HeroTypes GetTypes(Hero entity) => entity.GetHeroTypes();
		public bool HasAllTypes(Hero entity, HeroTypes types) => entity.HasAllTypes(types);
		public bool HasAnyType(Hero entity, HeroTypes types) => entity.HasAnyType(types);
		public string FormattedDetails(Hero entity) => entity.FormattedDetails();
	}
}
FILE: HeroGenerator.cs
using System;
using System.Collections.Generic;
using System.Linq;
using Bannerlord.GameMaster.Characters;
using Bannerlord.GameMaster.Console.HeroCommands;
using Bannerlord.GameMaster.Cultures;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.CharacterDevelopment;
using TaleWorlds.CampaignSystem.ComponentInterfaces;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.Core;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.MountAndBlade;
using TaleWorlds.ObjectSystem;

namespace Bannerlord.GameMaster.Heroes
{
	/// <summary>
	/// Central system for creating heroes with flexible initialization options.
	/// Separates hero creation from role initialization to prevent hidden side effects.
	/// Now uses only Lord and Wanderer occupation characters to avoid notable occupation conflicts.
	/// </summary>
	public static class HeroGenerator
	{
		#region Core Creation - No Side Effects
	
			/// MARK: CreateBasicHero
			/// <summary>
			/// Creates a basic hero from a character object WITHOUT any occupation-specific initialization.
			/// This is the layer 1 foundation method - it only creates the hero object with basic properties.
			/// Use Initialize methods afterward to set up role-specific state (Lord, Wanderer, Companion).
			///
			/// IMPORTANT: Source characters should only be Lord or Wanderer occupation to avoid conflicts.
			/// CharacterTemplatePooler.GetAllHeroTemplatesFromFlags() ensures this by filtering out notables.
			/// </summary>
			/// <param name="sourceCharacter">Character to create hero from (Lord or Wanderer occupation only)</param>
			/// <param name="nameObj">Hero's name as TextObject</param>
			/// <param name="age">Hero's age (defaults to random between 18-30, and is forced to be atleast 18)</param>
			/// <param name="clan">Hero's clan (can be null for wanderers)</param>
			/// <returns">Created hero with occupation to be set by Initialize methods</returns>
			private static Hero CreateBasicHero(CharacterObject sourceCharacter, TextObject nameObj, int age = -1, Clan clan = null)
			{
				if (age < 18) //Prevents growing up prompts having to select a attribute
					age = RandomNumberGen.Instance.NextRandomInt(18, 31);
				
				string stringId = ObjectManager.Instance.GetUniqueStringId(nameObj, typeof(Hero));
				
				Hero hero = HeroCreator.CreateSpecialHero(sourceCharacter, age: age);
				
				hero.StringId = stringId;
				hero.SetName(nameObj, nameObj);
				hero.PreferredUpgradeFormation = FormationClass.Cavalry;
				hero.Gold = 1000;
				hero.Level = 10;
				hero.Clan = clan;
				hero.IsMinorFactionHero = false;
				
				// NOTE: Occupation is set by Initialize methods (InitializeAsLord, InitializeAsWanderer, etc.)
				// Source character's appearance is copied but occupation will be overridden
				
				return hero;
			}

		#endregion
		#region Role Initialization - Explicit Side Effects

		/// MARK: InitializeAsLord
			/// <summary>
			/// layer 2: Initializes a hero as a Lord with proper occupation, equipment, and optionally creates a party.
			/// Hero must have a clan assigned before calling this method.
			/// </summary>
			/// <param name="hero">Hero to initialize as Lord</param>
			/// <param name="homeSettlement">Settlement for hero's home (used for party spawn if creating party)</param>
			/// <param name="createParty">If true, creates a party for the lord if clan in below commander limit(default: true)</param>
			public static void InitializeAsLord(Hero hero, Settlement homeSettlement, bool createParty = true)
			{
				if (hero.Clan == null)
					throw new ArgumentException("Hero must have a clan assigned before initializing as Lord");
	
				hero.SetNewOccupation(Occupation.Lord);
				hero.IsMinorFactionHero = false;
				hero.EquipLordBasedOnCulture();
				hero.UpdateHomeSettlement();
				hero.Gold = 10000;
				hero.Level = 10;
		
				if (createParty && hero.Clan.WarPartyComponents.Count < hero.Clan.CommanderLimit)
				{
					hero.CreateParty(homeSettlement ?? hero.GetHomeOrAlternativeSettlement());
				}
		
				hero.UpdateLastKnownClosestSettlement(homeSettlement ?? hero.GetHomeOrAlternativeSettlement());
				hero.UpdatePowerModifier();
				
				// CRITICAL: Initialize hero to set IsInitialized = true
				// Without this, when clans receive settlements and notables are transferred,
				// the uninitialized clan leader can cause notable state corruption
				hero.Initialize();
			}

			/// MARK: InitializeAsWanderer
			/// <summary>
			/// layer 2: Initializes a hero as a Wanderer (recruitable companion in settlement).
			/// Sets clan to null, equips basic gear, and places hero in specified settlement.
			/// </summary>
			/// <param name="hero">Hero to initialize as Wanderer</param>
			/// <param name="settlement">Settlement where wanderer will wait</param>
			public static void InitializeAsWanderer(Hero hero, Settlement settlement)
			{
				hero.Clan = null;
				hero.SetNewOccupation(Occupation.Wanderer); // Crashes if not set to wanderer when you talk to them
				hero.IsMinorFactionHero = false;
				hero.EquipHeroBasedOnCulture();
				hero.Gold = 1000;
				hero.Level = 8;
				
				EnterSettlementAction.ApplyForCharacterOnly(hero, settlement);
				hero.UpdateLastKnownClosestSettlement(settlement);
				
				// CRITICAL: Initialize hero to set IsInitialized = true
				hero.Initialize();
			}
	
			/// MARK: InitializeAsCompanion
			/// <summary>
			/// layer 2: Initializes a hero as a Companion ready to be added to a party.
			/// Does NOT place hero in settlement - hero is in neutral active state ready for party roster.
			/// Use MobilePartyExtensions.AddCompanionToParty() after calling this method.
			/// </summary>
			/// <param name="hero">Hero to initialize as Companion</param>
			public static void InitializeAsCompanion(Hero hero)
			{
				// Keep clan assignment (should be set by caller)
				hero.SetNewOccupation(Occupation.Lord); // Ensures character is lord (if wanderer the backstory dialog shows error text. Still functions like a wanderer)
				hero.IsMinorFactionHero = false;
				hero.ChangeState(Hero.CharacterStates.Active);
				hero.EquipHeroBasedOnCulture();
				hero.Gold = 1000;
				hero.Level = 8;
				
				// CRITICAL: Initialize hero to set IsInitialized = true
				hero.Initialize();
				
				// Don't place in settlement - hero is ready for party addition
			}

			/// MARK: CleanupHeroState
			/// <summary>
			/// Cleans up a hero's state by removing them from parties and settlements.
			/// Useful when moving heroes between roles or clans.
			/// </summary>
			/// <param name="hero">Hero to clean up</param>
			public static void CleanupHeroState(Hero hero)
			{
				// Destroy existing party if hero owns it
				if (hero.PartyBelongedTo != null && hero.PartyBelongedTo.Owner == hero)
				{
					DestroyPartyAction.Apply(null, hero.PartyBelongedTo);
				}

				// Remove from settlement if present
				if (hero.CurrentSettlement != null)
				{
					LeaveSettlementAction.ApplyForCharacterOnly(hero);
				}
			}

			#endregion
			#region High-Level Convenience Methods

			/// MARK: CreateLord
			/// <summary>
			/// Creates a lord with the specified name and culture, optionally with a party.
			/// This is a high-level convenience method that combines creation and initialization.
			/// </summary>
			/// <param name="name">Name for the lord</param>
			/// <param name="cultureFlags">Culture pool to select from</param>
			/// <param name="genderFlags">Gender selection</param>
			/// <param name="clan">Clan for the lord (required)</param>
			/// <param name="withParty">If true, creates a party for the lord if clan is below commander limit</param>
			/// <param name="randomFactor">Appearance randomization factor (0-1)</param>
			/// <returns>Created and initialized lord</returns>
			public static Hero CreateLord(string name, CultureFlags cultureFlags, GenderFlags genderFlags, Clan clan, bool withParty = true, float randomFactor = 0.5f)
			{
				if (clan == null)
					throw new ArgumentException("Clan is required for Lord creation");

				var template = SelectRandomTemplate(cultureFlags, genderFlags, randomFactor);
				TextObject nameObj = new TextObject(name);
				
				Hero hero = CreateBasicHero(template, nameObj, -1, clan);
				Settlement homeSettlement = hero.GetHomeOrAlternativeSettlement();
				InitializeAsLord(hero, homeSettlement, withParty);
				
				return hero;
			}

			/// MARK: CreateLords
			/// <summary>
			/// Creates multiple lords with random names from culture.
			/// <param name="withParty">If true, creates a party for each lord if clan is below commander limit</param>
			/// </summary>
			public static List<Hero> CreateLords(int count, CultureFlags cultureFlags, GenderFlags genderFlags, Clan clan, bool withParties = true, float randomFactor = 0.5f)
			{
				if (clan == null)
					throw new ArgumentException("Clan is required for Lord creation");

				List<Hero> lords = new List<Hero>();
				CharacterTemplatePooler templatePooler = new CharacterTemplatePooler();
				List<CharacterObject> characterPool = templatePooler.GetAllHeroTemplatesFromFlags(cultureFlags, genderFlags);
		
				for (int i = 0; i < count; i++)
				{
					var character = SelectRandomTemplate(characterPool, randomFactor);
					string randomName = CultureLookup.GetUniqueRandomHeroName(character.Culture, character.IsFemale);
					TextObject nameObj = new TextObject(randomName);
		
					Hero hero = CreateBasicHero(character, nameObj, -1, clan);
					Settlement homeSettlement = hero.GetHomeOrAlternativeSettlement();
					InitializeAsLord(hero, homeSettlement, withParties);
					
					lords.Add(hero);
				}
		
				return lords;
			}

			/// MARK: CreateWanderer
			/// <summary>
			/// Creates a wanderer (recruitable companion) at the specified settlement. Layer 3: Convenience method, automatically performing layer 1 and 2 operations.
			/// </summary>
			public static Hero CreateWanderer(string name, CultureFlags cultureFlags, GenderFlags genderFlags, Settlement settlement, float randomFactor = 0.5f)
			{
				var template = SelectRandomTemplate(cultureFlags, genderFlags, randomFactor);
				TextObject nameObj = new TextObject(name);
				
				Hero hero = CreateBasicHero(template, nameObj);
				InitializeAsWanderer(hero, settlement);
				
				return hero;
			}

			/// MARK: CreateWanderers
			/// <summary>
			/// Creates multiple wanderers with random names at the specified settlement. Layer 3: Convenience method, automatically performing layer 1 and 2 operations.
			/// </summary>
			public static List<Hero> CreateWanderers(int count, CultureFlags cultureFlags, GenderFlags genderFlags, Settlement settlement, float randomFactor = 0.5f)
			{
				List<Hero> wanderers = new List<Hero>();
				CharacterTemplatePooler templatePooler = new CharacterTemplatePooler();
				List<CharacterObject> characterPool = templatePooler.GetAllHeroTemplatesFromFlags(cultureFlags, genderFlags);
		
				for (int i = 0; i < count; i++)
				{
					var character = SelectRandomTemplate(characterPool, randomFactor);
					string randomName = CultureLookup.GetUniqueRandomHeroName(character.Culture, character.IsFemale);
					TextObject nameObj = new TextObject(randomName);
		
					Hero hero = CreateBasicHero(character, nameObj);
					InitializeAsWanderer(hero, settlement);
					
					wanderers.Add(hero);
				}
		
				return wanderers;
			}
	
			/// MARK: CreateCompanions
			/// <summary>
			/// Creates heroes ready to be added as party companions (no settlement state). Layer 3: Convenience method, automatically performing layer 1 and 2 operations.
			/// Use MobilePartyExtensions.AddCompanionsToParty() after calling this method.
			/// </summary>
			public static List<Hero> CreateCompanions(int count, CultureFlags cultureFlags, GenderFlags genderFlags = GenderFlags.Either, float randomFactor = 0.5f)
			{
				List<Hero> companions = new List<Hero>();
				CharacterTemplatePooler templatePooler = new CharacterTemplatePooler();
				List<CharacterObject> characterPool = templatePooler.GetAllHeroTemplatesFromFlags(cultureFlags, genderFlags);
		
				for (int i = 0; i < count; i++)
				{
					var character = SelectRandomTemplate(characterPool, randomFactor);
					string randomName = CultureLookup.GetUniqueRandomHeroName(character.Culture, character.IsFemale);
					TextObject nameObj = new TextObject(randomName);
		
					Hero hero = CreateBasicHero(character, nameObj, -1);
					InitializeAsCompanion(hero);
					
					companions.Add(hero);
				}
		
				return companions;
			}

			#endregion
			#region Helper Methods
		
			/// MARK: SelectRandomTemplate
			/// <summary>
			/// Selects and optionally randomizes a character from the given culture/gender pool.
			/// Only returns Lord and Wanderer occupation characters (no notables).
			/// </summary>
			private static CharacterObject SelectRandomTemplate(CultureFlags cultureFlags, GenderFlags genderFlags, float randomFactor)
			{
				CharacterTemplatePooler templatePooler = new CharacterTemplatePooler();
				List<CharacterObject> characterPool = templatePooler.GetAllHeroTemplatesFromFlags(cultureFlags, genderFlags);
				return SelectRandomTemplate(characterPool, randomFactor);
			}
	
			/// MARK: SelectRandomTemplate (Overload)
			/// <summary>
			/// Selects and optionally randomizes a character from the given pool.
			/// Creates a copy of the character and optionally randomizes appearance.
			/// </summary>
			private static CharacterObject SelectRandomTemplate(List<CharacterObject> characterPool, float randomFactor)
			{
				int randomIndex = RandomNumberGen.Instance.NextRandomInt(characterPool.Count);
				CharacterObject character = CharacterObject.CreateFrom(characterPool[randomIndex]);
		
				if (randomFactor > 0)
					character = RandomizeCharacterObject(character, randomFactor);
		
				return character;
			}

			/// MARK: RandomizeCharacterObject
			/// <summary>
			/// Randomizes character appearance within template constraints
			/// </summary>
			public static CharacterObject RandomizeCharacterObject(CharacterObject template, float randomFactor, bool useFaceConstraints = true, bool useBuildConstraints = true, bool useHairConstraints = true)
			{
				int _seed = RandomNumberGen.Instance.NextRandomInt();

				BodyProperties minBodyProperties = template.GetBodyPropertiesMin();
				BodyProperties maxBodyProperties = template.GetBodyPropertiesMax();

				int hairCoverType = HairCoveringType.None;
				string hairTags = HairTags.All;
				string beardTags = BeardTags.All;
				string tatooTags = TattooTags.None;

				BodyProperties randomProperties = TaleWorlds.Core.FaceGen.GetRandomBodyProperties(template.Race, template.IsFemale,
						minBodyProperties, maxBodyProperties, hairCoverType, _seed, hairTags, beardTags, tatooTags, randomFactor);

				return template;
			}

			#endregion
	}
}
FILE: HeroQueries.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using Bannerlord.GameMaster.Console.Common;

namespace Bannerlord.GameMaster.Heroes
{
	/// <summary>
	/// Provides utility methods for working with hero entities.
	/// </summary>
	public static class HeroQueries
	{
		#region Query

		/// <summary>
		/// Finds a hero with the specified heroId, using a case-insensitive comparison.
		/// </summary>
		public static Hero GetHeroById(string heroId)
		{
			return Hero.FindFirst(h => h.StringId.Equals(heroId, StringComparison.OrdinalIgnoreCase));
		}

		/// <summary>
		/// Main unified method to find heroes by search string and type flags
		/// </summary>
		/// <param name="query">Optional case-insensitive substring to filter by name or ID</param>
		/// <param name="requiredTypes">Hero type flags that ALL must match (AND logic)</param>
		/// <param name="matchAll">If true, hero must have ALL flags. If false, hero must have ANY flag</param>
		/// <param name="includeDead">If true, searches dead heroes instead of alive ones</param>
		/// <param name="sortBy">Sort field (id, name, age, clan, kingdom, or any HeroType flag)</param>
		/// <param name="sortDescending">True for descending, false for ascending</param>
		/// <returns>List of heroes matching all criteria</returns>
		public static List<Hero> QueryHeroes(
			string query = "",
			HeroTypes requiredTypes = HeroTypes.None,
			bool matchAll = true,
			bool includeDead = false,
			string sortBy = "id",
			bool sortDescending = false)
		{
			// Handle player alias - "player" is an alias for "main_hero"
			if (!string.IsNullOrEmpty(query) && query.Equals("player", StringComparison.OrdinalIgnoreCase))
			{
				query = "main_hero";
			}

			IEnumerable<Hero> heroes;

			// When using OR logic with life status flags (Alive or Dead), search both collections
			// to ensure we find all matching heroes regardless of life status
			if (!matchAll && requiredTypes != HeroTypes.None &&
				(requiredTypes.HasFlag(HeroTypes.Alive) || requiredTypes.HasFlag(HeroTypes.Dead)))
			{
				// Search both alive and dead heroes for OR queries involving life status
				heroes = Hero.AllAliveHeroes.Concat(Hero.DeadOrDisabledHeroes);
			}
			else
			{
				// For AND queries or queries without life status flags, use the standard collection
				heroes = includeDead ? Hero.DeadOrDisabledHeroes : Hero.AllAliveHeroes;
			}

			// Filter by name/ID if provided
			if (!string.IsNullOrEmpty(query))
			{
				string lowerFilter = query.ToLower();
				heroes = heroes.Where(h =>
					h.Name.ToString().ToLower().Contains(lowerFilter) ||
					h.StringId.ToLower().Contains(lowerFilter));
			}

			// Filter by hero types
			if (requiredTypes != HeroTypes.None)
			{
				heroes = heroes.Where(h => matchAll ? h.HasAllTypes(requiredTypes) : h.HasAnyType(requiredTypes));
			}

			// Apply sorting
			heroes = ApplySorting(heroes, sortBy, sortDescending);

			return heroes.ToList();
		}

		#endregion
		#region Sorting

		/// <summary>
		/// Apply sorting to heroes collection
		/// </summary>
		private static IEnumerable<Hero> ApplySorting(
			IEnumerable<Hero> heroes,
			string sortBy,
			bool descending)
		{
			sortBy = sortBy.ToLower();

			// Check if sortBy matches a HeroType flag
			if (Enum.TryParse<HeroTypes>(sortBy, true, out var heroType) && heroType != HeroTypes.None)
			{
				// Sort by whether hero has this type flag
				return descending
					? heroes.OrderByDescending(h => h.GetHeroTypes().HasFlag(heroType))
					: heroes.OrderBy(h => h.GetHeroTypes().HasFlag(heroType));
			}

			// Sort by standard fields
			IOrderedEnumerable<Hero> orderedHeroes = sortBy switch
			{
				"name" => descending
					? heroes.OrderByDescending(h => h.Name.ToString())
					: heroes.OrderBy(h => h.Name.ToString()),
				"age" => descending
					? heroes.OrderByDescending(h => h.Age)
					: heroes.OrderBy(h => h.Age),
				"clan" => descending
					? heroes.OrderByDescending(h => h.Clan?.Name?.ToString() ?? "")
					: heroes.OrderBy(h => h.Clan?.Name?.ToString() ?? ""),
				"kingdom" => descending
					? heroes.OrderByDescending(h => h.Clan?.Kingdom?.Name?.ToString() ?? "")
					: heroes.OrderBy(h => h.Clan?.Kingdom?.Name?.ToString() ?? ""),
				_ => descending  // default to id
					? heroes.OrderByDescending(h => h.StringId)
					: heroes.OrderBy(h => h.StringId)
			};

			return orderedHeroes;
		}

		#endregion
		#region Parsing / Formatting

		/// <summary>
		/// Parse a string into HeroTypes enum value
		/// </summary>
		public static HeroTypes ParseHeroType(string typeString)
		{
			if (Enum.TryParse<HeroTypes>(typeString, true, out var result))
				return result;
			return HeroTypes.None;
		}

		/// <summary>
		/// Parse multiple strings and combine into HeroTypes flags
		/// </summary>
		public static HeroTypes ParseHeroTypes(IEnumerable<string> typeStrings)
		{
			HeroTypes combined = HeroTypes.None;
			foreach (var typeString in typeStrings)
			{
				var parsed = ParseHeroType(typeString);
				if (parsed != HeroTypes.None)
					combined |= parsed;
			}
			return combined;
		}

		/// <summary>
		/// Returns a formatted string listing hero details with aligned columns
		/// </summary>
		public static string GetFormattedDetails(List<Hero> heroes)
		{
			if (heroes.Count == 0)
				return "";

			return ColumnFormatter<Hero>.FormatList(
				heroes,
				h => h.StringId,
				h => h.Name.ToString(),
				h => $"Culture: {h.Culture?.Name?.ToString() ?? "None"}",
				h => $"Level: {h.Level}",
				h => $"Gender: {(h.IsFemale ? "Female" : "Male")}",
				h => $"Clan: {h.Clan?.Name?.ToString() ?? "None"}",
				h => $"Kingdom: {h.Clan?.Kingdom?.Name?.ToString() ?? "None"}"
			);
		}

		#endregion
	}

	#region Wrapper

	/// <summary>
	/// Wrapper class implementing IEntityQueries interface for Hero entities
	/// </summary>
	public class HeroQueriesWrapper : IEntityQueries<Hero, HeroTypes>
	{
		public Hero GetById(string id) => HeroQueries.GetHeroById(id);
		public List<Hero> Query(string query, HeroTypes types, bool matchAll) => HeroQueries.QueryHeroes(query, types, matchAll);
		public HeroTypes ParseType(string typeString) => HeroQueries.ParseHeroType(typeString);
		public HeroTypes ParseTypes(IEnumerable<string> typeStrings) => HeroQueries.ParseHeroTypes(typeStrings);
		public string GetFormattedDetails(List<Hero> entities) => HeroQueries.GetFormattedDetails(entities);
	}

	#endregion
}
FILE: InfoMessage.cs
using TaleWorlds.Library;

namespace Bannerlord.GameMaster.Information
{
    public static class InfoMessage
    {
        /// <summary>
        /// Default White information message used as general log messages for BLGM
        /// </summary>
        public static void Log(string message)
        {
            Write(message, Color.White);
        }

        /// <summary>
        /// Green information message used as success messages for BLGM
        /// </summary>
        public static void Success(string message)
        {
            Write(message, Colors.Green);
        }

        /// <summary>
        /// Yellow information message used as warning messages for BLGM
        /// </summary>
        public static void Warning(string message)
        {
            Write(message, Colors.Yellow);
        }

        /// <summary>
        /// Red information message used as Error messages for BLGM
        /// </summary>
        public static void Error(string message)
        {
            Write(message, Colors.Red);
        }

        /// <summary>
        /// Magenta information message used for attention grabbing important messages for BLGM
        /// </summary>
        public static void Important(string message)
        {
            Write(message, Colors.Magenta);
        }

        /// <summary>
        /// Cyan information message used as status messages for BLGM
        /// </summary>
        public static void Status(string message)
        {
            Write(message, Colors.Cyan);
        }

        /// <summary>
        /// Blue information message used as alternate status messages for BLGM
        /// </summary>
        public static void Status2(string message)
        {
            Write(message, Colors.Cyan);
        }

        /// <summary>
        /// Information message allowing for custom color
        /// </summary>
        public static void Write(string message, Color color)
        {
            InformationManager.DisplayMessage(new InformationMessage(message));
        }
    }
}
FILE: ItemExtensions.cs
using System;
using TaleWorlds.Core;
using Bannerlord.GameMaster.Common.Interfaces;

namespace Bannerlord.GameMaster.Items
{
    [Flags]
    public enum ItemTypes
    {
        None = 0,
        Weapon = 1,
        Armor = 2,
        Mount = 4,
        Food = 8,
        Trade = 16,
        OneHanded = 32,
        TwoHanded = 64,
        Ranged = 128,
        Shield = 256,
        HeadArmor = 512,
        BodyArmor = 1024,
        LegArmor = 2048,
        HandArmor = 4096,
        Cape = 8192,
        Thrown = 16384,
        Arrows = 32768,
        Bolts = 65536,
        Polearm = 131072,
        Banner = 262144,
        Goods = 524288,
        Bow = 1048576,
        Crossbow = 2097152,
        Civilian = 4194304,
        Combat = 8388608,
        HorseArmor = 16777216
    }

    /// <summary>
    /// Extension methods for ItemObject entities
    /// </summary>
    public static class ItemExtensions
    {
        /// <summary>
        /// Gets all item type flags for this item
        /// </summary>
        public static ItemTypes GetItemTypes(this ItemObject item)
        {
            ItemTypes types = ItemTypes.None;

            if (item.IsFood) types |= ItemTypes.Food;
            if (item.IsBannerItem) types |= ItemTypes.Banner;

            // Determine if item is civilian or combat
            bool isCombatItem = false;
            bool isCivilianItem = false;

            // Weapon types
            switch (item.ItemType)
            {
                case ItemObject.ItemTypeEnum.OneHandedWeapon:
                    types |= ItemTypes.Weapon | ItemTypes.OneHanded;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.TwoHandedWeapon:
                    types |= ItemTypes.Weapon | ItemTypes.TwoHanded;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Polearm:
                    types |= ItemTypes.Weapon | ItemTypes.Polearm;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Bow:
                    types |= ItemTypes.Weapon | ItemTypes.Ranged | ItemTypes.Bow;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Crossbow:
                    types |= ItemTypes.Weapon | ItemTypes.Ranged | ItemTypes.Crossbow;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Thrown:
                    types |= ItemTypes.Weapon | ItemTypes.Thrown;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Arrows:
                    types |= ItemTypes.Arrows;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Bolts:
                    types |= ItemTypes.Bolts;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Shield:
                    types |= ItemTypes.Shield;
                    isCombatItem = true;
                    break;
                case ItemObject.ItemTypeEnum.Horse:
                    types |= ItemTypes.Mount;
                    break;
                case ItemObject.ItemTypeEnum.HorseHarness:
                    types |= ItemTypes.HorseArmor;
                    break;
                case ItemObject.ItemTypeEnum.Goods:
                    types |= ItemTypes.Goods | ItemTypes.Trade;
                    isCivilianItem = true;
                    break;
                case ItemObject.ItemTypeEnum.HeadArmor:
                    types |= ItemTypes.Armor | ItemTypes.HeadArmor;
                    break;
                case ItemObject.ItemTypeEnum.BodyArmor:
                    types |= ItemTypes.Armor | ItemTypes.BodyArmor;
                    break;
                case ItemObject.ItemTypeEnum.LegArmor:
                    types |= ItemTypes.Armor | ItemTypes.LegArmor;
                    break;
                case ItemObject.ItemTypeEnum.HandArmor:
                    types |= ItemTypes.Armor | ItemTypes.HandArmor;
                    break;
                case ItemObject.ItemTypeEnum.Cape:
                    types |= ItemTypes.Armor | ItemTypes.Cape;
                    break;
            }

            // Check if armor is civilian (has IsCivilian property in game)
            if (item.ArmorComponent != null)
            {
                // In Mount & Blade, civilian armor can be identified by having no armor value or being marked as civilian
                if (item.ArmorComponent.HeadArmor == 0 &&
                    item.ArmorComponent.BodyArmor == 0 &&
                    item.ArmorComponent.ArmArmor == 0 &&
                    item.ArmorComponent.LegArmor == 0)
                {
                    isCivilianItem = true;
                }
                else
                {
                    isCombatItem = true;
                }
            }

            // Apply civilian/combat flags
            if (isCivilianItem) types |= ItemTypes.Civilian;
            if (isCombatItem) types |= ItemTypes.Combat;

            // Food items are also civilian
            if (item.IsFood) types |= ItemTypes.Civilian;

            return types;
        }

        /// <summary>
        /// Checks if item has ALL specified flags
        /// </summary>
        public static bool HasAllTypes(this ItemObject item, ItemTypes types)
        {
            if (types == ItemTypes.None) return true;
            var itemTypes = item.GetItemTypes();
            return (itemTypes & types) == types;
        }

        /// <summary>
        /// Checks if item has ANY of the specified flags
        /// </summary>
        public static bool HasAnyType(this ItemObject item, ItemTypes types)
        {
            if (types == ItemTypes.None) return true;
            var itemTypes = item.GetItemTypes();
            return (itemTypes & types) != ItemTypes.None;
        }

        /// <summary>
        /// Returns a formatted string containing the item's details
        /// </summary>
        public static string FormattedDetails(this ItemObject item)
        {
            // Note: ItemTiers enum values are offset by 1 (Tier0=-1, Tier1=0, Tier2=1, etc.)
            // So we add 1 to display the user-friendly tier number
            string tier = (int)item.Tier >= -1 ? $"Tier: {(int)item.Tier + 1}" : "Tier: N/A";
            return $"{item.StringId}\t{item.Name}\tType: {item.ItemType}\tValue: {item.Value}\t{tier}";
        }

        /// <summary>
        /// Alias for GetItemTypes to match IEntityExtensions interface
        /// </summary>
        public static ItemTypes GetTypes(this ItemObject item) => item.GetItemTypes();
    }

    /// <summary>
    /// Wrapper class implementing IEntityExtensions interface for ItemObject entities
    /// </summary>
    public class ItemExtensionsWrapper : IEntityExtensions<ItemObject, ItemTypes>
    {
        public ItemTypes GetTypes(ItemObject entity) => entity.GetItemTypes();
        public bool HasAllTypes(ItemObject entity, ItemTypes types) => entity.HasAllTypes(types);
        public bool HasAnyType(ItemObject entity, ItemTypes types) => entity.HasAnyType(types);
        public string FormattedDetails(ItemObject entity) => entity.FormattedDetails();
    }
}
FILE: ItemModifierHelper.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.Core;
using TaleWorlds.ObjectSystem;

namespace Bannerlord.GameMaster.Items
{
    /// <summary>
    /// Helper methods for working with item modifiers (quality levels)
    /// </summary>
    public static class ItemModifierHelper
    {
        /// <summary>
        /// Get all available item modifiers from the game
        /// </summary>
        public static List<ItemModifier> GetAllModifiers()
        {
            var modifiers = new List<ItemModifier>();
            
            // Get all modifiers from the game's MBObjectManager
            foreach (var modifier in MBObjectManager.Instance.GetObjectTypeList<ItemModifier>())
            {
                modifiers.Add(modifier);
            }
            
            return modifiers;
        }

        /// <summary>
        /// Find a modifier by name (case-insensitive partial match)
        /// </summary>
        public static ItemModifier GetModifierByName(string modifierName)
        {
            if (string.IsNullOrEmpty(modifierName))
                return null;

            string lowerName = modifierName.ToLower();
            var allModifiers = MBObjectManager.Instance.GetObjectTypeList<ItemModifier>();
            
            // Try exact match first
            var exactMatch = allModifiers
                .FirstOrDefault(m => m.Name.ToString().Equals(modifierName, StringComparison.OrdinalIgnoreCase));
            
            if (exactMatch != null)
                return exactMatch;
            
            // Try contains match
            var containsMatch = allModifiers
                .FirstOrDefault(m => m.Name.ToString().ToLower().Contains(lowerName));
            
            return containsMatch;
        }

        /// <summary>
        /// Get a list of modifier names for display
        /// </summary>
        public static string GetFormattedModifierList()
        {
            var modifiers = GetAllModifiers()
                .OrderBy(m => m.Name.ToString())
                .ToList();
            
            if (modifiers.Count == 0)
                return "No modifiers available.\n";
            
            return string.Join("\n", modifiers.Select(m => 
                $"{m.StringId}\t{m.Name}\tPrice Factor: {m.PriceMultiplier:F2}")) + "\n";
        }

        /// <summary>
        /// Check if an item can have modifiers (weapons and armor typically can)
        /// </summary>
        public static bool CanHaveModifier(ItemObject item)
        {
            if (item == null)
                return false;

            // Items with weapon or armor components can typically have modifiers
            return item.WeaponComponent != null || item.ArmorComponent != null;
        }

        /// <summary>
        /// Get modifier info as formatted string
        /// </summary>
        public static string GetModifierInfo(ItemModifier modifier)
        {
            if (modifier == null)
                return "No modifier";

            return $"{modifier.Name} (ID: {modifier.StringId}, Price: x{modifier.PriceMultiplier:F2})";
        }

        /// <summary>
        /// Parse modifier name with suggestions for close matches
        /// </summary>
        public static (ItemModifier modifier, string error) ParseModifier(string modifierName)
        {
            if (string.IsNullOrEmpty(modifierName))
                return (null, null); // No modifier is valid

            var modifier = GetModifierByName(modifierName);
            
            if (modifier != null)
                return (modifier, null);

            // Provide suggestions
            var allModifiers = GetAllModifiers();
            var suggestions = allModifiers
                .Where(m => m.Name.ToString().ToLower().StartsWith(modifierName.ToLower()))
                .Take(5)
                .ToList();

            if (suggestions.Count > 0)
            {
                string suggestionList = string.Join(", ", suggestions.Select(m => m.Name.ToString()));
                return (null, $"Modifier '{modifierName}' not found. Did you mean: {suggestionList}?");
            }

            return (null, $"Modifier '{modifierName}' not found. Use gm.query.modifiers to see all available modifiers.");
        }

        /// <summary>
        /// Common quality modifiers (for convenience/quick reference)
        /// </summary>
        public static class CommonModifiers
        {
            public static ItemModifier Fine => GetModifierByName("Fine");
            public static ItemModifier Masterwork => GetModifierByName("Masterwork");
            public static ItemModifier Legendary => GetModifierByName("Legendary");
            public static ItemModifier Bent => GetModifierByName("Bent");
            public static ItemModifier Chipped => GetModifierByName("Chipped");
            public static ItemModifier Rusty => GetModifierByName("Rusty");
            public static ItemModifier Cracked => GetModifierByName("Cracked");
            public static ItemModifier Balanced => GetModifierByName("Balanced");
            public static ItemModifier Sharp => GetModifierByName("Sharp");
            public static ItemModifier Heavy => GetModifierByName("Heavy");
        }
    }
}
FILE: ItemQueries.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.Core;
using TaleWorlds.ObjectSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using Bannerlord.GameMaster.Console.Common;

namespace Bannerlord.GameMaster.Items
{
    /// <summary>
    /// Provides utility methods for querying item entities
    /// </summary>
    public static class ItemQueries
    {
        /// <summary>
        /// Finds an item with the specified itemId, using a case-insensitive comparison
        /// </summary>
        public static ItemObject GetItemById(string itemId)
        {
            return MBObjectManager.Instance.GetObject<ItemObject>(itemId);
        }

        /// <summary>
        /// Main unified method to find items by search string and type flags
        /// </summary>
        /// <param name="query">Optional case-insensitive substring to filter by name, ID, or tier</param>
        /// <param name="requiredTypes">Item type flags that ALL must match (AND logic)</param>
        /// <param name="matchAll">If true, item must have ALL flags. If false, item must have ANY flag</param>
        /// <param name="tierFilter">Optional tier filter (0-6, -1 for no filter)</param>
        /// <param name="sortBy">Sort field (name, tier, value, type, id)</param>
        /// <param name="sortDescending">True for descending, false for ascending</param>
        /// <returns>List of items matching all criteria</returns>
        public static List<ItemObject> QueryItems(
            string query = "",
            ItemTypes requiredTypes = ItemTypes.None,
            bool matchAll = true,
            int tierFilter = -1,
            string sortBy = "id",
            bool sortDescending = false)
        {
            IEnumerable<ItemObject> items = MBObjectManager.Instance.GetObjectTypeList<ItemObject>();

            // Filter by name/ID/tier if provided
            if (!string.IsNullOrEmpty(query))
            {
                string lowerFilter = query.ToLower();
                items = items.Where(i =>
                    i.Name.ToString().ToLower().Contains(lowerFilter) ||
                    i.StringId.ToLower().Contains(lowerFilter) ||
                    (i.Tier >= 0 && i.Tier.ToString().Contains(lowerFilter)));
            }

            // Filter by item types
            if (requiredTypes != ItemTypes.None)
            {
                items = items.Where(i =>
                    matchAll ? i.HasAllTypes(requiredTypes) : i.HasAnyType(requiredTypes));
            }

            // Filter by tier
            // Note: ItemTiers enum values are offset by 1 (Tier0=-1, Tier1=0, Tier2=1, etc.)
            // So we subtract 1 from the user's tier input to match the enum value
            if (tierFilter >= 0)
            {
                items = items.Where(i => (int)i.Tier == tierFilter - 1);
            }

            // Apply sorting
            items = ApplySorting(items, sortBy, sortDescending);

            return items.ToList();
        }

        /// <summary>
        /// Apply sorting to items collection
        /// </summary>
        private static IEnumerable<ItemObject> ApplySorting(
            IEnumerable<ItemObject> items,
            string sortBy,
            bool descending)
        {
            sortBy = sortBy.ToLower();

            IOrderedEnumerable<ItemObject> orderedItems = sortBy switch
            {
                "name" => descending
                    ? items.OrderByDescending(i => i.Name.ToString())
                    : items.OrderBy(i => i.Name.ToString()),
                "tier" => descending
                    ? items.OrderByDescending(i => i.Tier)
                    : items.OrderBy(i => i.Tier),
                "value" => descending
                    ? items.OrderByDescending(i => i.Value)
                    : items.OrderBy(i => i.Value),
                "type" => descending
                    ? items.OrderByDescending(i => i.ItemType.ToString())
                    : items.OrderBy(i => i.ItemType.ToString()),
                _ => descending  // default to id
                    ? items.OrderByDescending(i => i.StringId)
                    : items.OrderBy(i => i.StringId)
            };

            return orderedItems;
        }

        /// <summary>
        /// Parse a string into ItemTypes enum value
        /// </summary>
        public static ItemTypes ParseItemType(string typeString)
        {
            // Handle common aliases
            var normalized = typeString.ToLower() switch
            {
                "1h" => "OneHanded",
                "2h" => "TwoHanded",
                "head" => "HeadArmor",
                "body" => "BodyArmor",
                "leg" => "LegArmor",
                "hand" => "HandArmor",
                _ => typeString
            };

            return Enum.TryParse<ItemTypes>(normalized, true, out var result) 
                ? result : ItemTypes.None;
        }

        /// <summary>
        /// Parse multiple strings and combine into ItemTypes flags
        /// </summary>
        public static ItemTypes ParseItemTypes(IEnumerable<string> typeStrings)
        {
            ItemTypes combined = ItemTypes.None;
            foreach (var typeString in typeStrings)
            {
                var parsed = ParseItemType(typeString);
                if (parsed != ItemTypes.None)
                    combined |= parsed;
            }
            return combined;
        }

        /// <summary>
        /// Returns a formatted string listing item details with aligned columns
        /// </summary>
        public static string GetFormattedDetails(List<ItemObject> items)
        {
            if (items.Count == 0)
                return "";

            return ColumnFormatter<ItemObject>.FormatList(
                items,
                i => i.StringId,
                i => i.Name.ToString(),
                i => $"Type: {i.ItemType}",
                i => $"Value: {i.Value}",
                i => {
                    // Note: ItemTiers enum values are offset by 1
                    string tier = (int)i.Tier >= -1 ? $"Tier: {(int)i.Tier + 1}" : "Tier: N/A";
                    return tier;
                }
            );
        }
    }

    /// <summary>
    /// Wrapper class implementing IEntityQueries interface for ItemObject entities
    /// </summary>
    public class ItemQueriesWrapper : IEntityQueries<ItemObject, ItemTypes>
    {
        public ItemObject GetById(string id) => ItemQueries.GetItemById(id);
        public List<ItemObject> Query(string query, ItemTypes types, bool matchAll) => 
            ItemQueries.QueryItems(query, types, matchAll);
        public ItemTypes ParseType(string typeString) => ItemQueries.ParseItemType(typeString);
        public ItemTypes ParseTypes(IEnumerable<string> typeStrings) => 
            ItemQueries.ParseItemTypes(typeStrings);
        public string GetFormattedDetails(List<ItemObject> entities) => 
            ItemQueries.GetFormattedDetails(entities);
    }
}
FILE: KingdomAllianceExtensions.cs
using System;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.CampaignBehaviors;
using TaleWorlds.CampaignSystem.Election;

namespace Bannerlord.GameMaster.Kingdoms
{
    public static class KingdomAllianceExtensions
    {
        /// <summary>
		/// Forms an alliance with specified kingdom <br/>
        /// callToWar will only auto call the ally to war for the player if the player is the proposing kingdom
		/// </summary>
		public static void DeclareAlliance(this Kingdom proposingKindom, Kingdom receivingkingdom, bool callToWar = true)
		{
			FactionManager.SetNeutral(receivingkingdom, proposingKindom);	
			StartAllianceDecision allianceDecision = new(proposingKindom.RulingClan, receivingkingdom);
			
            // receivingkingdom.AddDecision(allianceDecision, ignoreInfluenceCost: true); //Not needed to add to queue if auto accepting (suppresses notification)
			
            StartAllianceDecision.StartAllianceDecisionOutcome outcome = new(true, proposingKindom, receivingkingdom);
			allianceDecision.ApplyChosenOutcome(outcome);

			if (callToWar)
            {   
                // Clears auto generated call to war notification (doesnt work, notification not cleared)
                //ClearCallToWarProposalDecisions(proposingKindom);
                //ClearCallToWarProposalDecisions(receivingkingdom);
     
				ProposeCallAllyToWarForceAccept(proposingKindom, receivingkingdom);
            }
		}

		/// <summary>
		/// Proposes to ally to join war against target kingdom and forces ally to accept
		/// </summary>
		public static void ProposeCallAllyToWarForceAccept(this Kingdom proposer, Kingdom ally, Kingdom enemy)
		{
			ProposeCallAllyToWar(proposer, ally, enemy);
			AcceptCallAllyToWar(proposer, ally, enemy);  // Fixed parameter order
		}

		/// <summary>
		/// Proposes to ally to join war against all kingdoms the proposer is at war with and forces ally to accept
		/// </summary>
		public static void ProposeCallAllyToWarForceAccept(this Kingdom proposer, Kingdom ally)
		{
			ProposeCallAllyToWar(proposer, ally);
			AcceptCallAllyToWar(proposer, ally);  // Fixed parameter order
		}

		/// <summary>
		/// Proposes to ally to join war against target enemy kingdom
		/// </summary>
		public static void ProposeCallAllyToWar(this Kingdom proposer, Kingdom ally, Kingdom enemy)
		{			
			ProposeCallToWarAgreementDecision decision = new(proposer.RulingClan, ally, enemy);
			
            //proposer.AddDecision(decision, ignoreInfluenceCost: true); // Not needed to add to queue if auto accepting (suppresses notification)
			
			ProposeCallToWarAgreementDecision.ProposeCallToWarAgreementDecisionOutcome outcome = new(true, proposer, ally, enemy);
			decision.ApplyChosenOutcome(outcome);
		}

		/// <summary>
		/// Proposes to ally to join war against all kingdoms the proposer is at war with
		/// </summary>
		public static void ProposeCallAllyToWar(this Kingdom proposer, Kingdom ally)
		{			
			foreach(IFaction enemy in proposer.FactionsAtWarWith)
			{
				if (enemy.IsKingdomFaction)
					ProposeCallAllyToWar(proposer, ally, (Kingdom)enemy); // Fixed: was AcceptCallAllyToWar
			}	
		}

		/// <summary>
		/// Forces ally to accept any proposals to join war against target enemy kingdom
		/// </summary>
		public static void AcceptCallAllyToWar(this Kingdom proposer, Kingdom ally, Kingdom enemy)
		{			
			AcceptCallToWarAgreementDecision decision = new(proposer.RulingClan, ally, enemy);
			
            //ally.AddDecision(decision, ignoreInfluenceCost: true); //Not needed to add to queue if auto accepting (suppresses notification)
			
			AcceptCallToWarAgreementDecision.AcceptCallToWarAgreementDecisionOutcome outcome = 
				new(true, proposer, ally, enemy);
			decision.ApplyChosenOutcome(outcome);
		}

		/// <summary>
		/// Forces ally to accept any proposals to join war against all kingdoms proposer is at war with
		/// </summary>
		public static void AcceptCallAllyToWar(this Kingdom proposer, Kingdom ally)
		{			
			foreach(IFaction targetKingdom in proposer.FactionsAtWarWith)
			{
				if (targetKingdom.IsKingdomFaction)
					AcceptCallAllyToWar(proposer, ally, (Kingdom)targetKingdom);
			}	
		}

        /// <summary>
        /// Used to clear CallToWar notification on alliance formed, if call to war is true on DeclareAlliance method
        /// </summary>
        /// <param name="kingdom"></param>
        private static void ClearCallToWarProposalDecisions(Kingdom kingdom)
        {
            // Convert MBReadOnlyList to IEnumerable first, then use LINQ
            var decisionsToRemove = kingdom.UnresolvedDecisions
                .Where(d => d is ProposeCallToWarAgreementDecision)
                .Cast<ProposeCallToWarAgreementDecision>()
                .ToList();
            
            foreach (var decision in decisionsToRemove)
                kingdom.UnresolvedDecisions.Remove(decision);
        }
    }
}
FILE: KingdomExtensions.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using SandBox.Issues;
using SandBox.GauntletUI.AutoGenerated1;
using Helpers;
using TaleWorlds.CampaignSystem.ComponentInterfaces;
using TaleWorlds.CampaignSystem.GameComponents;
using TaleWorlds.CampaignSystem.ViewModelCollection.KingdomManagement.Diplomacy;
using TaleWorlds.CampaignSystem.Election;
using TaleWorlds.CampaignSystem.ViewModelCollection.KingdomManagement.Decisions.ItemTypes;

namespace Bannerlord.GameMaster.Kingdoms
{
	/// MARK: Types
	[Flags]
	public enum KingdomTypes
	{
		None = 0,
		Active = 1,
		Eliminated = 2,
		Empty = 4,
		PlayerKingdom = 8,
		AtWar = 16,
	}

	public static class KingdomExtensions
	{
		/// <summary>
		/// Gets all kingdom type flags for this kingdom
		/// </summary>
		public static KingdomTypes GetKingdomTypes(this Kingdom kingdom)
		{
			KingdomTypes types = KingdomTypes.None;

			if (kingdom.IsEliminated)
				types |= KingdomTypes.Eliminated;
			else
				types |= KingdomTypes.Active;

			// Check if kingdom has no clans or heroes
			if (kingdom.Clans.Count == 0 || kingdom.Heroes.Count() == 0)
				types |= KingdomTypes.Empty;

			if (kingdom == Hero.MainHero.MapFaction as Kingdom)
				types |= KingdomTypes.PlayerKingdom;

			// Check if at war with anyone
			bool atWar = false;
			foreach (var otherKingdom in Kingdom.All)
			{
				if (otherKingdom != kingdom && FactionManager.IsAtWarAgainstFaction(kingdom, otherKingdom))
				{
					atWar = true;
					break;
				}
			}
			if (atWar)
				types |= KingdomTypes.AtWar;

			return types;
		}

		/// <summary>
		/// Checks if kingdom has ALL specified flags
		/// </summary>
		public static bool HasAllTypes(this Kingdom kingdom, KingdomTypes types)
		{
			if (types == KingdomTypes.None) return true;
			var kingdomTypes = kingdom.GetKingdomTypes();
			return (kingdomTypes & types) == types;
		}

		/// <summary>
		/// Checks if kingdom has ANY of the specified flags
		/// </summary>
		public static bool HasAnyType(this Kingdom kingdom, KingdomTypes types)
		{
			if (types == KingdomTypes.None) return true;
			var kingdomTypes = kingdom.GetKingdomTypes();
			return (kingdomTypes & types) != KingdomTypes.None;
		}

		/// MARK: Formatted Details
		/// <summary>
		/// Returns a formatted string containing the kingdom's details
		/// </summary>
		public static string FormattedDetails(this Kingdom kingdom)
		{
			int heroCount = kingdom.Heroes.Count();
			return $"{kingdom.StringId}\t{kingdom.Name}\tClans: {kingdom.Clans.Count}\tHeroes: {heroCount}\t" +
				   $"RulingClan: {kingdom.RulingClan?.Name}\tRuler: {kingdom.Leader?.Name}";
		}

		/// <summary>
		/// Alias for GetKingdomTypes to match IEntityExtensions interface
		/// </summary>
		public static KingdomTypes GetTypes(this Kingdom kingdom) => kingdom.GetKingdomTypes();
	}

	/// MARK: Wrapper
	/// <summary>
	/// Wrapper class implementing IEntityExtensions interface for Kingdom entities
	/// </summary>
	public class KingdomExtensionsWrapper : IEntityExtensions<Kingdom, KingdomTypes>
	{
		public KingdomTypes GetTypes(Kingdom entity) => entity.GetKingdomTypes();
		public bool HasAllTypes(Kingdom entity, KingdomTypes types) => entity.HasAllTypes(types);
		public bool HasAnyType(Kingdom entity, KingdomTypes types) => entity.HasAnyType(types);
		public string FormattedDetails(Kingdom entity) => entity.FormattedDetails();
	}
}
FILE: KingdomGenerator.cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using Bannerlord.GameMaster.Characters;
using Bannerlord.GameMaster.Clans;
using Bannerlord.GameMaster.Cultures;
using Bannerlord.GameMaster.Heroes;
using Bannerlord.GameMaster.Information;
using Bannerlord.GameMaster.Party;
using Helpers;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.Core;
using TaleWorlds.Localization;

namespace Bannerlord.GameMaster.Kingdoms
{
    public class KingdomGenerator
    {
        /// MARK: Create Kingdom
        /// <summary>
        /// Creates a new kingdom with the specified ruling clan and home settlement.
        /// </summary>
        /// <param name="homeSettlement">Capital settlement (auto-resolves if null/invalid)</param>
        /// <param name="name">Kingdom name (generates random if null)</param>
        /// <param name="rulingClanName">Name of the Clan ruling to rule the kingdom (generates random if null)</param>
        /// <returns>The created kingdom, or null if settlement cannot be resolved</returns>
        public static Kingdom CreateKingdom(Settlement homeSettlement, int vassalClanCount = 4, string name = null, string rulingClanName = null, CultureFlags cultureFlags = CultureFlags.AllMainCultures)
        {
            // Early validation of settlement
            if (homeSettlement == null || homeSettlement.Town == null)
                return null;

            if (!homeSettlement.IsTown && !homeSettlement.IsCastle)
                return null;

            // Create ruling clan
            Clan rulingClan = ClanGenerator.CreateClan(rulingClanName, cultureFlags: cultureFlags);

            if (name == null || name.IsEmpty())
                name = CultureLookup.GetUniqueRandomKingdomName(rulingClan.Leader.Culture);

            TextObject nameObj = new(name);
            string stringID = ObjectManager.Instance.GetUniqueStringId(nameObj, typeof(Kingdom));

            // Prepare clan for ruling BEFORE creating kingdom
            PrepareClanToRule(rulingClan);

            // Create kingdom
            Kingdom kingdom = Kingdom.CreateKingdom(stringID);

            // Move clan to new kingdom
            ChangeKingdomAction.ApplyByCreateKingdom(rulingClan, kingdom, true);
            
            CultureObject culture = rulingClan.Culture;

            // banner is null atleast on vanilla clans, so use originalBanner if null
            Banner banner;
            if (rulingClan.Banner != null)
                banner = rulingClan.Banner;
            else
                banner = rulingClan.ClanOriginalBanner;

            uint kingdomColor1 = rulingClan.Color;
            uint kingdomColor2 = rulingClan.Color2;
        
            // Links seem to not show up in encyclopedia, keeping them anyway as still shows text correctly.
            TextObject encyclopediaText = new($"A new rising kingdom sparked from the upstarts of {rulingClan.EncyclopediaLinkWithName}, Taking {homeSettlement.EncyclopediaLinkWithName} as their capital " +
                                            $"and first ruled by {rulingClan.Leader.EncyclopediaLinkWithName}. Will their legitimacy as a sovereign nation be challenged?");
            TextObject encyclopediaTitle = nameObj;
            TextObject encyclopediaRulerTitle = new("{=kingdom_ruler_title}{?RULER.GENDER}Queen{?}King{\\?}");

            kingdom.InitializeKingdom(
                nameObj,                        // name
                nameObj,                        // informal name
                culture,                        // culture
                banner,                         // banner
                kingdomColor1,                  // color 1
                kingdomColor2,                  // color 2
                homeSettlement,                 // home settlement
                encyclopediaText,               // encyclopedia text
                encyclopediaTitle,              // encyclopedia title
                encyclopediaRulerTitle          // encyclopedia ruler title
            );

            // Transfer ownership of settlement
            ChangeOwnerOfSettlementAction.ApplyByDefault(rulingClan.Leader, homeSettlement);
            
            // Change homesettlement and bound villages culture to match to new kingdom
            homeSettlement.Culture = culture;
            foreach(Village village in homeSettlement.BoundVillages)
            {
                village.Settlement.Culture = culture;
            }

            // Calculate mid settlements for both kingdom and clan
            kingdom.CalculateMidSettlement();
            rulingClan.CalculateMidSettlement();

            // Initialize kingdom Wallets
            kingdom.KingdomBudgetWallet += 100000;
            kingdom.CallToWarWallet += 100000;
            kingdom.TributeWallet += 100000;


            if (rulingClan.Leader.PartyBelongedTo != null)
            {
                MobileParty rulerParty = rulingClan.Leader.PartyBelongedTo;              
                rulerParty.AddMixedTierTroops(30);
                rulerParty.UpgradeTroops();
            }

            // Generate vassals ensuring vassal count isnt negative
            if (vassalClanCount > 0)
            {
                List<Clan> clans = ClanGenerator.GenerateClans(vassalClanCount, cultureFlags, kingdom);
                
                // Add extra lords to vassals
                foreach(Clan clan in clans)
                    HeroGenerator.CreateLords(4, clan.Culture.ToCultureFlag(), GenderFlags.Either, clan);
            }

            // Set kingdom as ready AFTER all initialization is complete
            kingdom.IsReady = true;

            InfoMessage.Success($"Kingdom '{kingdom.Name}' created with {rulingClan.Name} as ruling clan and {homeSettlement.Name} as the capital and {vassalClanCount} vassal clans");
            
            return kingdom;
        }

        /// MARK: Prepare Clan for Rule
        /// <summary>
        /// Make sure clan is ready to be a ruling clan <br />
        /// Leaves kingdom if in one, forces correct state, sets tier to 6, add gold and influence, add 10 lords to clan
        /// </summary>
        static void PrepareClanToRule(Clan clan)
        {
            // Ensure clan isnt in kingdom already and their banner original colors are restored
            if (clan.Kingdom != null)
                clan.ClanLeaveKingdom(giveBackFiefs: false);

            if (clan.IsUnderMercenaryService)
                clan.EndMercenaryService(true);

            // Set correct states
            clan.IsNoble = true;
            clan.IsRebelClan = false;
            clan.Influence += 500;
            clan.Leader.Gold += 500000;

            if (clan.Leader.IsLord == false)
                clan.Leader.SetNewOccupation(Occupation.Lord);

            if (clan.Tier < 6)
                clan.SetClanTier(6);

            // Create extra lords for ruling clan
            HeroGenerator.CreateLords(10, clan.Culture.ToCultureFlag(), GenderFlags.Either, clan);
        }

        /// MARK: Generate Kingdoms
        /// <summary>
        /// Generates multiple kingdoms by taking settlements from existing kingdoms.
        /// Alternates between kingdoms evenly, ensuring not to take a kingdom's last settlement.
        /// Does not take settlements from the player's kingdom.
        /// </summary>
        /// <param name="count">Number of kingdoms to create</param>
        /// <param name="vassalClanCount">Number of vassal clans per kingdom</param>
        /// <param name="cultureFlags">Culture pool for kingdoms</param>
        /// <returns>List of created kingdoms</returns>
        public static List<Kingdom> GenerateKingdoms(int count, int vassalClanCount = 4, CultureFlags cultureFlags = CultureFlags.AllMainCultures)
        {
            List<Kingdom> createdKingdoms = new List<Kingdom>();

            // Get existing kingdoms that have more than 1 town/castle settlement
            var eligibleKingdoms = Kingdom.All
                .Where(k => k != Clan.PlayerClan?.Kingdom) // Exclude player kingdom
                .Where(k => k.Settlements.Count(s => s.IsTown || s.IsCastle) > 1)
                .ToList();

            if (eligibleKingdoms.Count == 0)
            {
                InfoMessage.Warning("No kingdoms with multiple settlements available for taking settlements.");
                return createdKingdoms;
            }

            // Build a pool of available settlements from these kingdoms
            var settlementPool = new List<Settlement>();
            foreach (var kingdom in eligibleKingdoms)
            {
                var kingdomSettlements = kingdom.Settlements
                    .Where(s => (s.IsTown || s.IsCastle) && s.OwnerClan != Clan.PlayerClan)
                    .ToList();

                // Only add settlements if the kingdom would still have at least 1 after taking one
                if (kingdomSettlements.Count > 1)
                {
                    // Add all but the last one to the pool (keep at least 1 for the kingdom)
                    settlementPool.AddRange(kingdomSettlements.Take(kingdomSettlements.Count - 1));
                }
            }

            if (settlementPool.Count == 0)
            {
                InfoMessage.Warning("No settlements available to create kingdoms without destroying existing ones.");
                return createdKingdoms;
            }

            // Organize settlements by their current kingdom to alternate evenly
            var settlementsByKingdom = settlementPool
                .GroupBy(s => s.MapFaction as Kingdom)
                .Where(g => g.Key != null)
                .ToDictionary(g => g.Key, g => g.ToList());

            // Create kingdoms by alternating between source kingdoms
            int kingdomsCreated = 0;
            int currentKingdomIndex = 0;
            var kingdomList = settlementsByKingdom.Keys.ToList();

            while (kingdomsCreated < count && settlementsByKingdom.Values.Any(list => list.Count > 0))
            {
                // Find the next kingdom that still has available settlements
                Kingdom sourceKingdom = null;
                int attempts = 0;
                while (attempts < kingdomList.Count)
                {
                    var testKingdom = kingdomList[currentKingdomIndex];
                    if (settlementsByKingdom[testKingdom].Count > 0)
                    {
                        sourceKingdom = testKingdom;
                        break;
                    }
                    currentKingdomIndex = (currentKingdomIndex + 1) % kingdomList.Count;
                    attempts++;
                }

                // No more settlements available
                if (sourceKingdom == null)
                    break;

                // Take the first available settlement from this kingdom
                var settlement = settlementsByKingdom[sourceKingdom][0];
                settlementsByKingdom[sourceKingdom].RemoveAt(0);

                // Verify the source kingdom still has at least one settlement left
                int remainingSettlements = sourceKingdom.Settlements.Count(s => (s.IsTown || s.IsCastle) && s != settlement);
                if (remainingSettlements < 1)
                {
                    InfoMessage.Warning($"Skipping settlement {settlement.Name} to prevent destroying {sourceKingdom.Name}");
                    currentKingdomIndex = (currentKingdomIndex + 1) % kingdomList.Count;
                    continue;
                }

                // Create kingdom with random names
                Kingdom newKingdom = CreateKingdom(
                    homeSettlement: settlement,
                    vassalClanCount: vassalClanCount,
                    name: null, // Random name
                    rulingClanName: null, // Random clan name
                    cultureFlags: cultureFlags
                );

                if (newKingdom != null)
                {
                    createdKingdoms.Add(newKingdom);
                    kingdomsCreated++;
                }

                // Move to next kingdom for alternation
                currentKingdomIndex = (currentKingdomIndex + 1) % kingdomList.Count;
            }

            if (kingdomsCreated < count)
            {
                InfoMessage.Warning($"Only created {kingdomsCreated} of {count} requested kingdoms. No more settlements available.");
            }

            return createdKingdoms;
        }
    }
}
FILE: KingdomQueries.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Party;
using Bannerlord.GameMaster.Common.Interfaces;
using Bannerlord.GameMaster.Console.Common;

namespace Bannerlord.GameMaster.Kingdoms
{
	public static class KingdomQueries
    {
        /// <summary>
        /// Finds a kingdom with the specified kingdomId, using a case-insensitive comparison.
        /// </summary>
        public static Kingdom GetKingdomById(string kingdomId)
        {
            return Kingdom.All.FirstOrDefault(k => k.StringId.Equals(kingdomId, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Main unified method to find kingdoms by search string and type flags
        /// </summary>
        /// <param name="query">Optional case-insensitive substring to filter by name or ID</param>
        /// <param name="requiredTypes">Kingdom type flags to match</param>
        /// <param name="matchAll">If true, kingdom must have ALL flags. If false, kingdom must have ANY flag</param>
        /// <param name="sortBy">Sort field (id, name, clans, heroes, fiefs, strength, or any KingdomType flag)</param>
        /// <param name="sortDescending">True for descending, false for ascending</param>
        /// <returns>List of kingdoms matching all criteria</returns>
        public static List<Kingdom> QueryKingdoms(
            string query = "",
            KingdomTypes requiredTypes = KingdomTypes.None,
            bool matchAll = true,
            string sortBy = "id",
            bool sortDescending = false)
        {
            IEnumerable<Kingdom> kingdoms = Kingdom.All;

            // Filter by name/ID if provided
            if (!string.IsNullOrEmpty(query))
            {
                string lowerFilter = query.ToLower();
                kingdoms = kingdoms.Where(k =>
                    k.Name.ToString().ToLower().Contains(lowerFilter) ||
                    k.StringId.ToLower().Contains(lowerFilter));
            }

            // Filter by kingdom types
            if (requiredTypes != KingdomTypes.None)
            {
                kingdoms = kingdoms.Where(k => matchAll ? k.HasAllTypes(requiredTypes) : k.HasAnyType(requiredTypes));
            }

            // Apply sorting
            kingdoms = ApplySorting(kingdoms, sortBy, sortDescending);

            return kingdoms.ToList();
        }

        /// <summary>
        /// Apply sorting to kingdoms collection
        /// </summary>
        private static IEnumerable<Kingdom> ApplySorting(
            IEnumerable<Kingdom> kingdoms,
            string sortBy,
            bool descending)
        {
            sortBy = sortBy.ToLower();

            // Check if sortBy matches a KingdomType flag
            if (Enum.TryParse<KingdomTypes>(sortBy, true, out var kingdomType) && kingdomType != KingdomTypes.None)
            {
                // Sort by whether kingdom has this type flag
                return descending
                    ? kingdoms.OrderByDescending(k => k.GetKingdomTypes().HasFlag(kingdomType))
                    : kingdoms.OrderBy(k => k.GetKingdomTypes().HasFlag(kingdomType));
            }

            // Sort by standard fields
            IOrderedEnumerable<Kingdom> orderedKingdoms = sortBy switch
            {
                "name" => descending
                    ? kingdoms.OrderByDescending(k => k.Name.ToString())
                    : kingdoms.OrderBy(k => k.Name.ToString()),
                "clans" => descending
                    ? kingdoms.OrderByDescending(k => k.Clans.Count)
                    : kingdoms.OrderBy(k => k.Clans.Count),
                "heroes" => descending
                    ? kingdoms.OrderByDescending(k => k.Heroes.Count())
                    : kingdoms.OrderBy(k => k.Heroes.Count()),
                "fiefs" => descending
                    ? kingdoms.OrderByDescending(k => k.Fiefs.Count)
                    : kingdoms.OrderBy(k => k.Fiefs.Count),
                "strength" => descending
                    ? kingdoms.OrderByDescending(k => k.CurrentTotalStrength)
                    : kingdoms.OrderBy(k => k.CurrentTotalStrength),
                "ruler" => descending
                    ? kingdoms.OrderByDescending(k => k.Leader?.Name?.ToString() ?? "")
                    : kingdoms.OrderBy(k => k.Leader?.Name?.ToString() ?? ""),
                _ => descending  // default to id
                    ? kingdoms.OrderByDescending(k => k.StringId)
                    : kingdoms.OrderBy(k => k.StringId)
            };

            return orderedKingdoms;
        }

        /// <summary>
        /// Parse a string into KingdomTypes enum value
        /// </summary>
        public static KingdomTypes ParseKingdomType(string typeString)
        {
            var normalizedType = typeString.ToLower() switch
            {
                "active" => "Active",
                "eliminated" => "Eliminated",
                "empty" => "Empty",
                "player" => "PlayerKingdom",
                "playerkingdom" => "PlayerKingdom",
                "atwar" => "AtWar",
                "war" => "AtWar",
                "hasallies" => "HasAllies",
                "allies" => "HasAllies",
                "allied" => "HasAllies",
                "hasenemies" => "HasEnemies",
                "enemies" => "HasEnemies",
                _ => typeString
            };

            if (Enum.TryParse<KingdomTypes>(normalizedType, true, out var result))
                return result;
            return KingdomTypes.None;
        }

        /// <summary>
        /// Parse multiple strings and combine into KingdomTypes flags
        /// </summary>
        public static KingdomTypes ParseKingdomTypes(IEnumerable<string> typeStrings)
        {
            KingdomTypes combined = KingdomTypes.None;
            foreach (var typeString in typeStrings)
            {
                var parsed = ParseKingdomType(typeString);
                if (parsed != KingdomTypes.None)
                    combined |= parsed;
            }
            return combined;
        }

        /// <summary>
        /// Returns a formatted string listing kingdom details with aligned columns
        /// </summary>
        public static string GetFormattedDetails(List<Kingdom> kingdoms)
        {
            if (kingdoms.Count == 0)
                return "";

            return ColumnFormatter<Kingdom>.FormatList(
                kingdoms,
                k => k.StringId,
                k => k.Name.ToString(),
                k => $"Clans: {k.Clans.Count}",
                k => $"Heroes: {k.Heroes.Count()}",
                k => $"RulingClan: {k.RulingClan?.Name?.ToString() ?? "None"}",
                k => $"Ruler: {k.Leader?.Name?.ToString() ?? "None"}"
            );
        }

        /// <summary>
        /// Get all clan leaders for a specific kingdom
        /// </summary>
        public static List<Hero> GetClanLeaders(Kingdom kingdom)
        {
            if (kingdom == null)
                return new List<Hero>();

            return kingdom.Clans
                .Where(c => c.Leader != null)
                .Select(c => c.Leader)
                .ToList();
        }

        /// <summary>
        /// Get all party leaders for a specific kingdom
        /// </summary>
        public static List<Hero> GetPartyLeaders(Kingdom kingdom)
        {
            if (kingdom == null)
                return new List<Hero>();

            return kingdom.AllParties
                .Where(p => p.LeaderHero != null)
                .Select(p => p.LeaderHero)
                .ToList();
        }

        /// <summary>
        /// Get all heroes in a specific kingdom
        /// </summary>
        public static List<Hero> GetHeroes(Kingdom kingdom)
        {
            if (kingdom == null)
                return new List<Hero>();

            return kingdom.Heroes.ToList();
        }
 }

 /// <summary>
 /// Wrapper class implementing IEntityQueries interface for Kingdom entities
 /// </summary>
 public class KingdomQueriesWrapper : IEntityQueries<Kingdom, KingdomTypes>
 {
  public Kingdom GetById(string id) => KingdomQueries.GetKingdomById(id);
  public List<Kingdom> Query(string query, KingdomTypes types, bool matchAll) => KingdomQueries.QueryKingdoms(query, types, matchAll);
  public KingdomTypes ParseType(string typeString) => KingdomQueries.ParseKingdomType(typeString);
  public KingdomTypes ParseTypes(IEnumerable<string> typeStrings) => KingdomQueries.ParseKingdomTypes(typeStrings);
  public string GetFormattedDetails(List<Kingdom> entities) => KingdomQueries.GetFormattedDetails(entities);
 }
}
FILE: KingdomTradeAgreementExtensions.cs
using System;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.CampaignBehaviors;
using TaleWorlds.CampaignSystem.Election;

namespace Bannerlord.GameMaster.Kingdoms
{
    public static class KingdomTradeAgreementExtensions
    {
        /// <summary>
		/// Forms a trade agreement with specified kingdom <br/>
        /// It doesn't matter which kingdom is the proposer
		/// </summary>
		public static void MakeTradeAgreement(this Kingdom proposingKindom, Kingdom receivingkingdom)
		{
			TradeAgreementDecision tradeDecision = new(proposingKindom.RulingClan, receivingkingdom);
			
            // receivingkingdom.AddDecision(tradeDecision, ignoreInfluenceCost: true); //Not needed to add to queue if auto accepting (suppresses notification)
			
            TradeAgreementDecision.TradeAgreementDecisionOutcome outcome = new(true, proposingKindom, receivingkingdom);
			tradeDecision.ApplyChosenOutcome(outcome);
		}
    }
}
FILE: KingdomTributeExtensions.cs
using TaleWorlds.CampaignSystem;

namespace Bannerlord.GameMaster.Kingdoms
{
	public static class KingdomTributeExtensions
	{
		/// <summary>
		/// Makes the kingdom pay the specified kingdom a daily tribute. Tributes between 2 kingdoms override eachother and do not accumulate<br />
		/// There can be multiple tributes between different kingdom, just not the same 2 kingdoms <br />
		/// A tribute can be canceled by setting a new tribute between the two kingdoms of 0 or by making the receiver pay the payer
		/// </summary>
		public static TributeInfo PayTribute(this Kingdom kingdom, Kingdom otherKingdom, int dailyAmount, int days)
		{
			TributeInfo tributeInfo = GetTributeInfo(kingdom, otherKingdom);
			tributeInfo.StanceLink.SetDailyTributePaid(kingdom, dailyAmount, days);
			
			return tributeInfo;
		}

		/// <summary>
		/// Returns a TributeInfo object containing information relating to any existing tributes between the two kingdoms
		/// </summary>
		/// <param name="kingdom"></param>
		/// <param name="otherKingdom"></param>
		/// <returns></returns>
		public static TributeInfo GetTributeInfo(this Kingdom kingdom, Kingdom otherKingdom)
		{
			TributeInfo tributeInfo = new(kingdom, otherKingdom);
			return tributeInfo;
		}
	}
	
	/// <summary>
	/// A struct containing tribute information between two kingdoms
	/// </summary>
	public struct TributeInfo
	{
		public Kingdom Kingdom { get; }
		public Kingdom OtherKingdom { get; }

		/// <summary>
		/// Indicates whether this TributeInfo has valid kingdoms.
		/// Invalid when: Kingdom is null, OtherKingdom is null, or both are the same kingdom.
		/// </summary>
		public bool IsValid => Kingdom != null && OtherKingdom != null && Kingdom != OtherKingdom;

		public StanceLink StanceLink => IsValid ? Kingdom.GetStanceWith(OtherKingdom) : null;

		public int KingdomToOtherDailyAmmount => IsValid ? StanceLink.GetDailyTributeToPay(Kingdom) : 0;
		public int KingdomToOtherTotalPaid => IsValid ? StanceLink.GetTotalTributePaid(Kingdom) : 0;
		public int OtherToKingdomDailyAmmount => IsValid ? StanceLink.GetDailyTributeToPay(OtherKingdom) : 0;
		public int OtherToKingdomTotalPaid => IsValid ? StanceLink.GetTotalTributePaid(OtherKingdom) : 0;
		public int RemainingDaysBoth => IsValid ? StanceLink.GetRemainingTributePaymentCount() : 0;

		/// <summary>
		/// Creates a TributeInfo for the specified kingdoms.
		/// Check IsValid property before accessing tribute data.
		/// </summary>
		public TributeInfo(Kingdom kingdom, Kingdom otherKingdom)
		{
			Kingdom = kingdom;
			OtherKingdom = otherKingdom;
		}

		/// <summary>
		/// Returns a message string showing which kingdom is paying which and how much
		/// </summary>
		/// <returns></returns>
		public string GetTributeString()
		{
			string tributeString = $"No tribute being paid between {Kingdom.Name} and {OtherKingdom.Name}";
			
			if (RemainingDaysBoth > 0)
			{	
				if (KingdomToOtherDailyAmmount > OtherToKingdomDailyAmmount)
					tributeString = $"{Kingdom.Name} is paying tribute to {OtherKingdom.Name}\n";

				else
					tributeString = $"{OtherKingdom.Name} is paying tribute to {Kingdom.Name}\n";

				tributeString += $"Daily Amount: {KingdomToOtherDailyAmmount}, Remaining Days: {RemainingDaysBoth}, Total Paid: {KingdomToOtherTotalPaid}";
			}
			
			return tributeString;
		}
	}
}
FILE: MobilePartyExtensions.cs
using System;
using System.Collections.Generic;
using System.Linq;
using Bannerlord.GameMaster.Console.TroopCommands;
using Bannerlord.GameMaster.Troops;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.CampaignSystem.Roster;
using TaleWorlds.Core;
using TaleWorlds.Library;

namespace Bannerlord.GameMaster.Party
{
	public static class MobilePartyExtensions
	{
		/// MARK: Companions
		/// <summary>
		/// Adds the specified hero as a companion to the leader's party
		/// </summary>
		public static void AddCompanionToParty(this MobileParty mobileParty, Hero hero)
		{
			// Use the game's built-in action which handles CompanionOf properly
			AddCompanionAction.Apply(mobileParty.LeaderHero.Clan, hero);
			mobileParty.AddElementToMemberRoster(hero.CharacterObject, 1);
			hero.ChangeState(Hero.CharacterStates.Active);
		}

		/// <summary>
		/// Adds the specified list of companions to the leader's party
		/// </summary>
		public static void AddCompanionsToParty(this MobileParty mobileParty, List<Hero> heroes)
		{
			foreach (Hero hero in heroes)
				mobileParty.AddCompanionToParty(hero);
		}

		/// MARK: Lords
		/// <summary>
		/// Adds the specified lord to the leader's party
		/// </summary>
		public static void AddLordToParty(this MobileParty mobileParty, Hero hero)
		{
			//hero.Clan = mobileParty.LeaderHero.Clan;  AddHeroToParty action should automatically make them a clan member		
			//mobileParty.AddElementToMemberRoster(hero.CharacterObject, 1);
			AddHeroToPartyAction.Apply(hero, mobileParty, true);
			hero.ChangeState(Hero.CharacterStates.Active); // Needed if not manually adding to roster?
		}

		/// <summary>
		/// Adds the specified list of lords to the leader's party
		/// </summary>
		public static void AddLordsToParty(this MobileParty mobileParty, List<Hero> heroes)
		{
			foreach (Hero hero in heroes)
				mobileParty.AddLordToParty(hero);
		}


		/// MARK: Troops
		/// <summary>
		/// Adds the specified ammount of elite troops from the party leader's culture
		/// </summary>
		public static void AddBasicTroops(this MobileParty mobileParty, int count)
		{
			if (mobileParty.LeaderHero.Culture.BasicTroop != null)
				mobileParty.AddElementToMemberRoster(mobileParty.LeaderHero.Culture.BasicTroop, count);
		}

		/// <summary>
		/// Adds the specified ammount of elite troops from the party leader's culture
		/// </summary>
		public static void AddEliteTroops(this MobileParty mobileParty, int count)
		{
			if (mobileParty.LeaderHero.Culture.EliteBasicTroop != null)
				mobileParty.AddElementToMemberRoster(mobileParty.LeaderHero.Culture.EliteBasicTroop, count);
		}

		/// <summary>
		/// Randomly selects the specified count of mercenary troops from party leader's culture.
		/// </summary>
		public static void AddMercenaryTroops(this MobileParty mobileParty, int count)
		{
			List<CharacterObject> mercenaryRoster = mobileParty.LeaderHero.Culture.BasicMercenaryTroops;

			for (int i = 0; i < count; i++)
			{
				int randomIndex = RandomNumberGen.Instance.NextRandomInt(mercenaryRoster.Count);
				mobileParty.AddElementToMemberRoster(mercenaryRoster[randomIndex], 1);
			}
		}

		/// <summary>
		/// Adds the specified ammount each of basic, elite, and mercenary troops from the party leader's culture<br/>
		/// countOfEach = 10 : Will add 30 troops. 10 basic, 10 elite, 10 mercenary.
		/// </summary>
		public static void AddMixedTierTroops(this MobileParty mobileParty, int countOfEach)
		{
			AddBasicTroops(mobileParty, countOfEach);
			AddEliteTroops(mobileParty, countOfEach);
			AddMercenaryTroops(mobileParty, countOfEach);
		}

		// MARK: UpgradeTroops
		/// <summary>
		/// Upgrades all troops in the party to the specified tier while maintaining desired composition ratios.
		/// When troops have multiple upgrade paths, intelligently splits them to achieve target ratios.
		/// </summary>
		/// <param name="targetTier">Maximum tier to upgrade to (default: max tier)</param>
		/// <param name="targetRangedRatio">Desired ratio of ranged troops (0.0-1.0, null for auto)</param>
		/// <param name="targetCavalryRatio">Desired ratio of cavalry troops (0.0-1.0, null for auto)</param>
		/// <param name="targetInfantryRatio">Desired ratio of infantry troops (0.0-1.0, null for auto)</param>
		public static void UpgradeTroops(this MobileParty mobileParty,
			int targetTier = 7,
			float? targetRangedRatio = null,
			float? targetCavalryRatio = null,
			float? targetInfantryRatio = null)
		{
			TroopUpgrader.UpgradeTroops(mobileParty.MemberRoster, targetTier, targetRangedRatio, targetCavalryRatio, targetInfantryRatio);
		}

		/// MARK: AddXp
		/// <summary>
		/// Add the specified experience to every troop in the party
		/// </summary>
		public static void AddXp(this MobileParty mobileParty, int xp)
		{
			foreach (TroopRosterElement troop in mobileParty.MemberRoster.GetTroopRoster())
			{
				if (troop.Character.IsHero)
					continue;

				mobileParty.MemberRoster.AddXpToTroop(troop.Character, xp);
			}
		}
	}
}
FILE: SettlementExtensions.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Settlements;
using Bannerlord.GameMaster.Common.Interfaces;

namespace Bannerlord.GameMaster.Settlements
{
    [Flags]
    public enum SettlementTypes : long
    {
        None = 0,
        Settlement = 1,         // 2^0  - General town (castle or city)
        Castle = 2,            // 2^1  - Castle specifically
        City = 4,              // 2^2  - City specifically
        Village = 8,           // 2^3  - Village
        Hideout = 16,          // 2^4  - Bandit hideout
        PlayerOwned = 32,      // 2^5  - Owned by player clan
        Besieged = 64,         // 2^6  - Currently under siege
        Raided = 128,          // 2^7  - Village is being raided
        Empire = 256,          // 2^8  - Empire culture
        Vlandia = 512,         // 2^9  - Vlandia culture
        Sturgia = 1024,        // 2^10 - Sturgia culture
        Aserai = 2048,         // 2^11 - Aserai culture
        Khuzait = 4096,        // 2^12 - Khuzait culture
        Battania = 8192,       // 2^13 - Battania culture
        Nord = 16384,          // 2^14 - Nord culture (Warsails DLC)
        LowProsperity = 32768, // 2^15 - Prosperity < 3000
        MediumProsperity = 65536, // 2^16 - Prosperity 3000-6000
        HighProsperity = 131072,  // 2^17 - Prosperity > 6000
    }

    public static class SettlementExtensions
    {
        /// <summary>
        /// Gets all settlement type flags for this settlement
        /// </summary>
        public static SettlementTypes GetSettlementTypes(this Settlement settlement)
        {
            SettlementTypes types = SettlementTypes.None;

            // Settlement type categories
            if (settlement.IsCastle)
            {
                types |= SettlementTypes.Castle;
                types |= SettlementTypes.Settlement;
            }
            else if (settlement.IsTown)
            {
                types |= SettlementTypes.City;
                types |= SettlementTypes.Settlement;
            }

            else if (settlement.IsHideout)
            {
                types |= SettlementTypes.Hideout;
            }

            if (settlement.IsVillage)
            {
                types |= SettlementTypes.Village;
            }

            // Ownership
            if (settlement.OwnerClan == Hero.MainHero.Clan)
            {
                types |= SettlementTypes.PlayerOwned;
            }

            // State flags
            if (settlement.IsUnderSiege)
            {
                types |= SettlementTypes.Besieged;
            }

            if (settlement.IsVillage && settlement.Village != null && settlement.Village.VillageState == Village.VillageStates.BeingRaided)
            {
                types |= SettlementTypes.Raided;
            }

            // Culture flags
            if (settlement.Culture != null)
            {
                string cultureId = settlement.Culture.StringId.ToLower();
                if (cultureId.Contains("empire"))
                    types |= SettlementTypes.Empire;
                else if (cultureId.Contains("vlandia"))
                    types |= SettlementTypes.Vlandia;
                else if (cultureId.Contains("sturgia"))
                    types |= SettlementTypes.Sturgia;
                else if (cultureId.Contains("aserai"))
                    types |= SettlementTypes.Aserai;
                else if (cultureId.Contains("khuzait"))
                    types |= SettlementTypes.Khuzait;
                else if (cultureId.Contains("battania"))
                    types |= SettlementTypes.Battania;
                else if (cultureId.Contains("nord"))
                    types |= SettlementTypes.Nord;
            }

            // Prosperity levels (for towns and villages)
            if ((settlement.IsTown || settlement.IsCastle) && settlement.Town != null)
            {
                float prosperity = settlement.Town.Prosperity;
                if (prosperity < 3000)
                    types |= SettlementTypes.LowProsperity;
                else if (prosperity <= 6000)
                    types |= SettlementTypes.MediumProsperity;
                else
                    types |= SettlementTypes.HighProsperity;
            }
            else if (settlement.IsVillage && settlement.Village != null)
            {
                float prosperity = settlement.Village.Hearth; // Villages use Hearth instead of Prosperity
                if (prosperity < 300)
                    types |= SettlementTypes.LowProsperity;
                else if (prosperity <= 600)
                    types |= SettlementTypes.MediumProsperity;
                else
                    types |= SettlementTypes.HighProsperity;
            }

            return types;
        }

        /// <summary>
        /// Checks if settlement has ALL specified flags
        /// </summary>
        public static bool HasAllTypes(this Settlement settlement, SettlementTypes types)
        {
            if (types == SettlementTypes.None) return true;
            var settlementTypes = settlement.GetSettlementTypes();
            return (settlementTypes & types) == types;
        }

        /// <summary>
        /// Checks if settlement has ANY of the specified flags
        /// </summary>
        public static bool HasAnyType(this Settlement settlement, SettlementTypes types)
        {
            if (types == SettlementTypes.None) return true;
            var settlementTypes = settlement.GetSettlementTypes();
            return (settlementTypes & types) != SettlementTypes.None;
        }

        /// <summary>
        /// Returns a formatted string containing the settlement's details
        /// </summary>
        public static string FormattedDetails(this Settlement settlement)
        {
            string settlementType = settlement.IsTown ? "City"
                : settlement.IsCastle ? "Castle"
                : settlement.IsVillage ? "Village"
                : settlement.IsHideout ? "Hideout"
                : "Unknown";

            string ownerName = settlement.OwnerClan?.Name?.ToString() ?? "None";
            string kingdomName = settlement.MapFaction?.Name?.ToString() ?? "None";
            string cultureName = settlement.Culture?.Name?.ToString() ?? "None";

            string prosperityInfo = "";
            if ((settlement.IsTown | settlement.IsCastle) && settlement.Town != null)
            {
                prosperityInfo = $"Prosperity: {settlement.Town.Prosperity:F0}";
            }
            else if (settlement.IsVillage && settlement.Village != null)
            {
                prosperityInfo = $"Hearth: {settlement.Village.Hearth:F0}";
            }

            return $"{settlement.StringId}\t{settlement.Name}\t[{settlementType}]\tOwner: {ownerName}\t" +
                   $"Kingdom: {kingdomName}\tCulture: {cultureName}\t{prosperityInfo}";
        }

        /// <summary>
        /// Alias for GetSettlementTypes to match IEntityExtensions interface
        /// </summary>
        public static SettlementTypes GetTypes(this Settlement settlement) => settlement.GetSettlementTypes();
    }

    /// <summary>
    /// Wrapper class implementing IEntityExtensions interface for Settlement entities
    /// </summary>
    public class SettlementExtensionsWrapper : IEntityExtensions<Settlement, SettlementTypes>
    {
        public SettlementTypes GetTypes(Settlement entity) => entity.GetSettlementTypes();
        public bool HasAllTypes(Settlement entity, SettlementTypes types) => entity.HasAllTypes(types);
        public bool HasAnyType(Settlement entity, SettlementTypes types) => entity.HasAnyType(types);
        public string FormattedDetails(Settlement entity) => entity.FormattedDetails();
    }
}
FILE: SettlementNameBehavior.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.SaveSystem;
using TaleWorlds.Localization;
using TaleWorlds.Library;

namespace Bannerlord.GameMaster.Settlements
{
    /// <summary>
    /// Campaign behavior that manages custom settlement names with save/load persistence.
    /// Stores both custom names and original names to allow reset functionality.
    /// Uses parallel lists for reliable serialization with TaleWorlds save system.
    /// </summary>
    public class SettlementNameBehavior : CampaignBehaviorBase
    {
        // Store as separate lists for reliable serialization
        private List<string> _settlementIds;
        private List<string> _customNames;
        private List<string> _originalNames;
        private FieldInfo _nameField;

        public SettlementNameBehavior()
        {
            _settlementIds = new List<string>();
            _customNames = new List<string>();
            _originalNames = new List<string>();
            // Cache the reflection field for performance
            _nameField = typeof(Settlement).GetField("_name", BindingFlags.NonPublic | BindingFlags.Instance);
        }

        public override void RegisterEvents()
        {
            // Register event to reapply names after load
            CampaignEvents.OnSessionLaunchedEvent.AddNonSerializedListener(this, OnSessionLaunched);
        }

        public override void SyncData(IDataStore dataStore)
        {
            // Sync as separate lists
            if (dataStore.IsSaving)
            {
                if (_settlementIds == null) _settlementIds = new List<string>();
                if (_customNames == null) _customNames = new List<string>();
                if (_originalNames == null) _originalNames = new List<string>();
                    
                // Debug logging before save
                InformationManager.DisplayMessage(new InformationMessage(
                    $"[GameMaster] Saving {_settlementIds.Count} custom settlement names",
                    Colors.Yellow));
            }
            
            dataStore.SyncData("CustomNameSettlementIds", ref _settlementIds);
            dataStore.SyncData("CustomNameValues", ref _customNames);
            dataStore.SyncData("OriginalNameValues", ref _originalNames);
            
            // Ensure lists are initialized after loading
            if (dataStore.IsLoading)
            {
                if (_settlementIds == null) _settlementIds = new List<string>();
                if (_customNames == null) _customNames = new List<string>();
                if (_originalNames == null) _originalNames = new List<string>();
                    
                // Debug logging
                InformationManager.DisplayMessage(new InformationMessage(
                    $"[GameMaster] Loaded {_settlementIds.Count} custom settlement names from save",
                    Colors.Cyan));
            }
        }

        /// <summary>
        /// Called after session is loaded. Reapplies all custom settlement names.
        /// </summary>
        private void OnSessionLaunched(CampaignGameStarter starter)
        {
            if (_settlementIds == null || _settlementIds.Count == 0)
                return;

            InformationManager.DisplayMessage(new InformationMessage(
                $"[GameMaster] Reapplying {_settlementIds.Count} custom settlement names",
                Colors.Cyan));

            for (int i = 0; i < _settlementIds.Count; i++)
            {
                var settlement = Settlement.Find(_settlementIds[i]);
                if (settlement != null)
                {
                    ApplyNameChange(settlement, _customNames[i]);
                }
            }
        }

        /// <summary>
        /// Renames a settlement and tracks the change for save persistence.
        /// </summary>
        /// <param name="settlement">The settlement to rename</param>
        /// <param name="newName">The new name for the settlement</param>
        /// <returns>True if successful, false otherwise</returns>
        public bool RenameSettlement(Settlement settlement, string newName)
        {
            if (settlement == null || string.IsNullOrWhiteSpace(newName))
            {
                InformationManager.DisplayMessage(new InformationMessage(
                    "[GameMaster] RenameSettlement called with null/empty parameters",
                    Colors.Red));
                return false;
            }

            try
            {
                // Find existing entry
                int index = _settlementIds.IndexOf(settlement.StringId);
                
                if (index >= 0)
                {
                    // Update existing
                    _customNames[index] = newName;
                    InformationManager.DisplayMessage(new InformationMessage(
                        $"[GameMaster] Updated existing entry for {settlement.StringId} to '{newName}'",
                        Colors.Green));
                }
                else
                {
                    // Add new
                    _settlementIds.Add(settlement.StringId);
                    _customNames.Add(newName);
                    _originalNames.Add(settlement.Name.ToString());
                    InformationManager.DisplayMessage(new InformationMessage(
                        $"[GameMaster] Added new entry: {settlement.StringId} = '{newName}' (count now: {_settlementIds.Count})",
                        Colors.Green));
                }

                // Apply the change
                ApplyNameChange(settlement, newName);

                return true;
            }
            catch (Exception ex)
            {
                InformationManager.DisplayMessage(new InformationMessage(
                    $"[GameMaster] Failed to rename settlement: {ex.Message}",
                    Colors.Red));
                return false;
            }
        }

        /// <summary>
        /// Resets a settlement to its original name.
        /// </summary>
        /// <param name="settlement">The settlement to reset</param>
        /// <returns>True if reset, false if settlement was not renamed</returns>
        public bool ResetSettlementName(Settlement settlement)
        {
            if (settlement == null)
                return false;

            int index = _settlementIds.IndexOf(settlement.StringId);
            if (index < 0)
                return false; // Not renamed

            try
            {
                // Get original name
                string originalName = _originalNames[index];

                // Apply original name
                ApplyNameChange(settlement, originalName);

                // Remove from lists
                _settlementIds.RemoveAt(index);
                _customNames.RemoveAt(index);
                _originalNames.RemoveAt(index);

                return true;
            }
            catch (Exception ex)
            {
                InformationManager.DisplayMessage(new InformationMessage(
                    $"[GameMaster] Failed to reset settlement name: {ex.Message}",
                    Colors.Red));
                return false;
            }
        }

        /// <summary>
        /// Resets all settlements to their original names.
        /// </summary>
        /// <returns>Number of settlements reset</returns>
        public int ResetAllSettlementNames()
        {
            if (_settlementIds.Count == 0)
                return 0;

            int resetCount = 0;
            var idsCopy = new List<string>(_settlementIds);

            foreach (var id in idsCopy)
            {
                var settlement = Settlement.Find(id);
                if (settlement != null && ResetSettlementName(settlement))
                {
                    resetCount++;
                }
            }

            return resetCount;
        }

        /// <summary>
        /// Gets the original name of a settlement if it was renamed.
        /// </summary>
        /// <param name="settlement">The settlement to check</param>
        /// <returns>Original name if renamed, null otherwise</returns>
        public string GetOriginalName(Settlement settlement)
        {
            if (settlement == null)
                return null;
                
            int index = _settlementIds.IndexOf(settlement.StringId);
            if (index < 0)
                return null;

            return _originalNames[index];
        }

        /// <summary>
        /// Checks if a settlement has been renamed.
        /// </summary>
        /// <param name="settlement">The settlement to check</param>
        /// <returns>True if the settlement has a custom name</returns>
        public bool IsRenamed(Settlement settlement)
        {
            return settlement != null && _settlementIds.Contains(settlement.StringId);
        }

        /// <summary>
        /// Gets the number of settlements with custom names.
        /// </summary>
        public int GetRenamedSettlementCount()
        {
            return _settlementIds.Count;
        }

        /// <summary>
        /// Applies a name change to a settlement using reflection.
        /// </summary>
        private void ApplyNameChange(Settlement settlement, string newName)
        {
            if (_nameField == null)
            {
                throw new InvalidOperationException("Unable to access Settlement._name field via reflection.");
            }

            _nameField.SetValue(settlement, new TextObject(newName));
        }
    }
}

FILE: SettlementQueries.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Settlements;
using Bannerlord.GameMaster.Common.Interfaces;
using Bannerlord.GameMaster.Console.Common;

namespace Bannerlord.GameMaster.Settlements
{
    /// <summary>
    /// Provides utility methods for querying Settlement entities
    /// </summary>
    public static class SettlementQueries
    {
        /// <summary>
        /// Finds a settlement with the specified ID, using case-insensitive comparison
        /// </summary>
        /// <param name="settlementId">The string ID of the settlement to find</param>
        /// <returns>The matching Settlement, or null if not found</returns>
        public static Settlement GetSettlementById(string settlementId)
        {
            return Settlement.All.FirstOrDefault(s => 
                s.StringId.Equals(settlementId, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Main unified method to find settlements by search string and type flags
        /// </summary>
        /// <param name="query">Optional case-insensitive substring to filter by name or ID</param>
        /// <param name="requiredTypes">Settlement type flags (AND logic by default)</param>
        /// <param name="matchAll">If true, settlement must have ALL flags. If false, ANY flag</param>
        /// <param name="sortBy">Sort field (id, name, prosperity, owner, kingdom, culture, or any SettlementType flag)</param>
        /// <param name="sortDescending">True for descending, false for ascending</param>
        /// <returns>List of settlements matching all criteria</returns>
        public static List<Settlement> QuerySettlements(
            string query = "",
            SettlementTypes requiredTypes = SettlementTypes.None,
            bool matchAll = true,
            string sortBy = "id",
            bool sortDescending = false)
        {
            IEnumerable<Settlement> settlements = Settlement.All;

            // Filter by name/ID if provided
            if (!string.IsNullOrEmpty(query))
            {
                string lowerFilter = query.ToLower();
                settlements = settlements.Where(s =>
                    s.Name.ToString().ToLower().Contains(lowerFilter) ||
                    s.StringId.ToLower().Contains(lowerFilter));
            }

            // Filter by types
            if (requiredTypes != SettlementTypes.None)
            {
                settlements = settlements.Where(s =>
                    matchAll ? s.HasAllTypes(requiredTypes) : s.HasAnyType(requiredTypes));
            }

            // Apply sorting
            settlements = ApplySorting(settlements, sortBy, sortDescending);

            return settlements.ToList();
        }

        /// <summary>
        /// Apply sorting to settlements collection
        /// </summary>
        private static IEnumerable<Settlement> ApplySorting(
            IEnumerable<Settlement> settlements,
            string sortBy,
            bool descending)
        {
            sortBy = sortBy.ToLower();

            // Check if sortBy matches a SettlementTypes flag
            if (Enum.TryParse<SettlementTypes>(sortBy, true, out var settlementType) && 
                settlementType != SettlementTypes.None)
            {
                return descending
                    ? settlements.OrderByDescending(s => s.GetSettlementTypes().HasFlag(settlementType))
                    : settlements.OrderBy(s => s.GetSettlementTypes().HasFlag(settlementType));
            }

            // Sort by standard fields
            IOrderedEnumerable<Settlement> orderedSettlements = sortBy switch
            {
                "name" => descending
                    ? settlements.OrderByDescending(s => s.Name.ToString())
                    : settlements.OrderBy(s => s.Name.ToString()),
                "prosperity" => descending
                    ? settlements.OrderByDescending(s => GetProsperityValue(s))
                    : settlements.OrderBy(s => GetProsperityValue(s)),
                "owner" => descending
                    ? settlements.OrderByDescending(s => s.OwnerClan?.Name?.ToString() ?? "")
                    : settlements.OrderBy(s => s.OwnerClan?.Name?.ToString() ?? ""),
                "kingdom" => descending
                    ? settlements.OrderByDescending(s => s.MapFaction?.Name?.ToString() ?? "")
                    : settlements.OrderBy(s => s.MapFaction?.Name?.ToString() ?? ""),
                "culture" => descending
                    ? settlements.OrderByDescending(s => s.Culture?.Name?.ToString() ?? "")
                    : settlements.OrderBy(s => s.Culture?.Name?.ToString() ?? ""),
                _ => descending  // default to id
                    ? settlements.OrderByDescending(s => s.StringId)
                    : settlements.OrderBy(s => s.StringId)
            };

            return orderedSettlements;
        }

        /// <summary>
        /// Helper method to get prosperity value for sorting
        /// </summary>
        private static float GetProsperityValue(Settlement settlement)
        {
            if (settlement.IsTown && settlement.Town != null)
                return settlement.Town.Prosperity;
            if (settlement.IsVillage && settlement.Village != null)
                return settlement.Village.Hearth;
            return 0f;
        }

        /// <summary>
        /// Parse a string into SettlementTypes enum value
        /// </summary>
        public static SettlementTypes ParseSettlementType(string typeString)
        {
            // Handle common aliases
            var normalized = typeString.ToLower() switch
            {
                "town" => "Town",
                "castle" => "Castle",
                "city" => "City",
                "village" => "Village",
                "hideout" => "Hideout",
                "player" => "PlayerOwned",
                "playerowned" => "PlayerOwned",
                "besieged" => "Besieged",
                "siege" => "Besieged",
                "raided" => "Raided",
                "empire" => "Empire",
                "vlandia" => "Vlandia",
                "sturgia" => "Sturgia",
                "aserai" => "Aserai",
                "khuzait" => "Khuzait",
                "battania" => "Battania",
                "nord" => "Nord",
                "lowprosperity" => "LowProsperity",
                "mediumprosperity" => "MediumProsperity",
                "highprosperity" => "HighProsperity",
                "low" => "LowProsperity",
                "medium" => "MediumProsperity",
                "high" => "HighProsperity",
                _ => typeString
            };

            return Enum.TryParse<SettlementTypes>(normalized, true, out var result)
                ? result : SettlementTypes.None;
        }

        /// <summary>
        /// Parse multiple strings and combine into SettlementTypes flags
        /// </summary>
        public static SettlementTypes ParseSettlementTypes(IEnumerable<string> typeStrings)
        {
            SettlementTypes combined = SettlementTypes.None;
            foreach (var typeString in typeStrings)
            {
                var parsed = ParseSettlementType(typeString);
                if (parsed != SettlementTypes.None)
                    combined |= parsed;
            }
            return combined;
        }

        /// <summary>
        /// Returns a formatted string listing settlement details with aligned columns
        /// </summary>
        public static string GetFormattedDetails(List<Settlement> settlements)
        {
            if (settlements.Count == 0)
                return "";

            return ColumnFormatter<Settlement>.FormatList(
                settlements,
                s => s.StringId,
                s => s.Name.ToString(),
                s => {
                    string type = s.IsTown ? "City"
                        : s.IsCastle ? "Castle"
                        : s.IsVillage ? "Village"
                        : s.IsHideout ? "Hideout"
                        : "Unknown";
                    return $"[{type}]";
                },
                s => $"Owner: {s.OwnerClan?.Name?.ToString() ?? "None"}",
                s => $"Kingdom: {s.MapFaction?.Name?.ToString() ?? "None"}",
                s => $"Culture: {s.Culture?.Name?.ToString() ?? "None"}",
                s => {
                    if ((s.IsTown | s.IsCastle) && s.Town != null)
                        return $"Prosperity: {s.Town.Prosperity:F0}";
                    else if (s.IsVillage && s.Village != null)
                        return $"Hearth: {s.Village.Hearth:F0}";
                    return "";
                }
            );
        }
    }

    /// <summary>
    /// Wrapper class implementing IEntityQueries interface for Settlement entities
    /// </summary>
    public class SettlementQueriesWrapper : IEntityQueries<Settlement, SettlementTypes>
    {
        public Settlement GetById(string id) => SettlementQueries.GetSettlementById(id);
        public List<Settlement> Query(string query, SettlementTypes types, bool matchAll)
            => SettlementQueries.QuerySettlements(query, types, matchAll);
        public SettlementTypes ParseType(string typeString) => SettlementQueries.ParseSettlementType(typeString);
        public SettlementTypes ParseTypes(IEnumerable<string> typeStrings)
            => SettlementQueries.ParseSettlementTypes(typeStrings);
        public string GetFormattedDetails(List<Settlement> entities)
            => SettlementQueries.GetFormattedDetails(entities);
    }
}
FILE: SettlementSaveDefiner.cs
using System.Collections.Generic;
using TaleWorlds.SaveSystem;

namespace Bannerlord.GameMaster.Settlements
{
    /// <summary>
    /// Defines saveable types for settlement customization data.
    /// Using ID range 900_000_000 for GameMaster mod to avoid conflicts.
    /// </summary>
    public class SettlementSaveDefiner : SaveableTypeDefiner
    {
        public SettlementSaveDefiner() : base(900_000_000) { }

        protected override void DefineClassTypes()
        {
            AddClassDefinition(typeof(SettlementNameData), 1);
        }

        protected override void DefineContainerDefinitions()
        {
            ConstructContainerDefinition(typeof(Dictionary<string, string>));
            ConstructContainerDefinition(typeof(List<string>));
        }
    }

    /// <summary>
    /// Saveable data class for custom settlement names.
    /// Stores both custom names and original names for reset functionality.
    /// Properties are automatically serialized by the TaleWorlds SaveSystem.
    /// </summary>
    public class SettlementNameData
    {
        /// <summary>
        /// Maps settlement StringId to custom name
        /// </summary>
        public Dictionary<string, string> CustomNames { get; set; }

        /// <summary>
        /// Maps settlement StringId to original name (for reset functionality)
        /// </summary>
        public Dictionary<string, string> OriginalNames { get; set; }

        public SettlementNameData()
        {
            CustomNames = new Dictionary<string, string>();
            OriginalNames = new Dictionary<string, string>();
        }
    }
}

FILE: TroopExtensions.cs
using System;
using System.Linq;
using TaleWorlds.Core;
using TaleWorlds.CampaignSystem;
using Bannerlord.GameMaster.Common.Interfaces;

namespace Bannerlord.GameMaster.Troops
{
    /// <summary>
    /// Flags enum for categorizing troop types across multiple dimensions
    /// </summary>
    [Flags]
    public enum TroopTypes : long
    {
        None = 0,
        
        // Formation/Combat Roles (1-16)
        Infantry = 1,              // 2^0  - FormationClass: Infantry
        Ranged = 2,                // 2^1  - FormationClass: Ranged
        Cavalry = 4,               // 2^2  - FormationClass: Cavalry
        HorseArcher = 8,           // 2^3  - FormationClass: HorseArcher
        Mounted = 16,              // 2^4  - IsMounted (Cavalry or HorseArcher)
        
        // Troop Line Categories (32-1024)
        Regular = 32,              // 2^5  - Culture's regular/main troop line
        Noble = 64,                // 2^6  - Culture's noble/elite troop line
        Militia = 128,             // 2^7  - Culture's militia (garrison) troop line
        Mercenary = 256,           // 2^8  - Mercenary troops
        Caravan = 512,             // 2^9  - Caravan guards/masters/traders
        Peasant = 1024,            // 2^10 - Villagers/peasants/townsfolk
        MinorFaction = 2048,       // 2^11 - Minor faction troops (Eleftheroi, Brotherhood, etc.)
        
        // Equipment-Based Categories (4096-65536)
        Shield = 4096,             // 2^12 - Has shield in equipment
        TwoHanded = 8192,          // 2^13 - Has two-handed weapon
        Polearm = 16384,           // 2^14 - Has polearm weapon
        Bow = 32768,               // 2^15 - Has bow
        Crossbow = 65536,          // 2^16 - Has crossbow
        ThrowingWeapon = 131072,   // 2^17 - Has throwing weapon
        
        // Tier-Based Categories (262144-33554432)
        Tier0 = 262144,            // 2^18 - Tier 0 troops
        Tier1 = 524288,            // 2^19 - Tier 1 troops
        Tier2 = 1048576,           // 2^20 - Tier 2 troops
        Tier3 = 2097152,           // 2^21 - Tier 3 troops
        Tier4 = 4194304,           // 2^22 - Tier 4 troops
        Tier5 = 8388608,           // 2^23 - Tier 5 troops
        Tier6Plus = 16777216,      // 2^24 - Tier 6+ troops (includes tier 7 if modded)
        
        // Culture-Based Categories (33554432-4294967296)
        Empire = 33554432,         // 2^25 - Culture: Empire
        Vlandia = 67108864,        // 2^26 - Culture: Vlandia
        Sturgia = 134217728,       // 2^27 - Culture: Sturgia
        Aserai = 268435456,        // 2^28 - Culture: Aserai
        Khuzait = 536870912,       // 2^29 - Culture: Khuzait
        Battania = 1073741824,     // 2^30 - Culture: Battania
        Nord = 2147483648,         // 2^31 - Culture: Nord (Warsails DLC - optional)
        Bandit = 4294967296,       // 2^32 - Culture: Bandit (special culture)
        
        // Gender Categories (8589934592-17179869184)
        Female = 8589934592,       // 2^33 - Female troops
        Male = 17179869184,        // 2^34 - Male troops
    }

    /// <summary>
    /// Extension methods for CharacterObject (troops) providing type categorization and formatting
    /// </summary>
    public static class TroopExtensions
    {
        /// <summary>
        /// Gets all troop type flags for this character
        /// CRITICAL: Heroes/Lords are NEVER troops - returns None immediately if IsHero is true
        /// </summary>
        public static TroopTypes GetTroopTypes(this CharacterObject character)
        {
            // CRITICAL: Heroes/Lords are never troops - exclude immediately
            if (character.IsHero)
                return TroopTypes.None;

            TroopTypes types = TroopTypes.None;

            // Formation/Combat Roles
            switch (character.DefaultFormationClass)
            {
                case FormationClass.Infantry:
                    types |= TroopTypes.Infantry;
                    break;
                case FormationClass.Ranged:
                    types |= TroopTypes.Ranged;
                    break;
                case FormationClass.Cavalry:
                    types |= TroopTypes.Cavalry;
                    types |= TroopTypes.Mounted;
                    break;
                case FormationClass.HorseArcher:
                    types |= TroopTypes.HorseArcher;
                    types |= TroopTypes.Mounted;
                    break;
            }

            // Troop Line Categories (based on StringId patterns and culture)
            // CRITICAL: Occupation is for HEROES not TROOPS - use StringId patterns instead
            var stringIdLower = character.StringId.ToLower();
            
            // Detect troop line by StringId patterns
            if (stringIdLower.Contains("noble") || stringIdLower.Contains("knight") ||
                stringIdLower.Contains("druzhnik") || stringIdLower.Contains("cataphract"))
            {
                types |= TroopTypes.Noble;
            }
            else if (stringIdLower.Contains("militia"))
            {
                types |= TroopTypes.Militia;
            }
            else if (stringIdLower.Contains("mercenary") && !stringIdLower.Contains("leader"))
            {
                types |= TroopTypes.Mercenary;
            }
            else if (stringIdLower.Contains("caravan_guard") || stringIdLower.Contains("caravan_master") ||
                     stringIdLower.Contains("armed_trader") || stringIdLower.Contains("sea_trader"))
            {
                types |= TroopTypes.Caravan;
            }
            else if ((stringIdLower.Contains("villager") || stringIdLower.Contains("village_woman") ||
                      stringIdLower.Contains("townsman") || stringIdLower.Contains("townswoman") ||
                      (stringIdLower.Contains("fighter") && character.GetBattleTier() == 0)) &&
                     character.GetBattleTier() == 0 && character.Level == 1)
            {
                types |= TroopTypes.Peasant;
            }
            else if (character.GetBattleTier() >= 2 &&
                     (stringIdLower.Contains("eleftheroi") || stringIdLower.Contains("brotherhood_of_woods") ||
                      stringIdLower.Contains("hidden_hand") || stringIdLower.Contains("jawwal") ||
                      stringIdLower.Contains("lake_rats") || stringIdLower.Contains("forest_people") ||
                      stringIdLower.Contains("karakhuzait")))
            {
                types |= TroopTypes.MinorFaction;
            }
            else if (character.Culture != null)
            {
                // Default to Regular for culture-based troops that aren't noble/militia/mercenary/caravan/peasant
                types |= TroopTypes.Regular;
            }

            // Equipment-Based Categories
            if (character.HasShield())
                types |= TroopTypes.Shield;
            if (character.HasTwoHandedWeapon())
                types |= TroopTypes.TwoHanded;
            if (character.HasPolearm())
                types |= TroopTypes.Polearm;
            if (character.HasWeaponType(ItemObject.ItemTypeEnum.Bow))
                types |= TroopTypes.Bow;
            if (character.HasWeaponType(ItemObject.ItemTypeEnum.Crossbow))
                types |= TroopTypes.Crossbow;
            if (character.HasWeaponType(ItemObject.ItemTypeEnum.Thrown))
                types |= TroopTypes.ThrowingWeapon;

            // Tier-Based Categories (exact tier mapping using GetBattleTier())
            int tier = character.GetBattleTier();
            if (tier == 0)
                types |= TroopTypes.Tier0;
            else if (tier == 1)
                types |= TroopTypes.Tier1;
            else if (tier == 2)
                types |= TroopTypes.Tier2;
            else if (tier == 3)
                types |= TroopTypes.Tier3;
            else if (tier == 4)
                types |= TroopTypes.Tier4;
            else if (tier == 5)
                types |= TroopTypes.Tier5;
            else if (tier >= 6)
                types |= TroopTypes.Tier6Plus;

            // Culture-Based Categories
            if (character.Culture != null)
            {
                string cultureId = character.Culture.StringId.ToLower();
                
                if (cultureId.Contains("empire"))
                    types |= TroopTypes.Empire;
                else if (cultureId.Contains("vlandia"))
                    types |= TroopTypes.Vlandia;
                else if (cultureId.Contains("sturgia"))
                    types |= TroopTypes.Sturgia;
                else if (cultureId.Contains("aserai"))
                    types |= TroopTypes.Aserai;
                else if (cultureId.Contains("khuzait"))
                    types |= TroopTypes.Khuzait;
                else if (cultureId.Contains("battania"))
                    types |= TroopTypes.Battania;
                else if (cultureId.Contains("nord"))
                    types |= TroopTypes.Nord;
                else if (cultureId.Contains("bandit") || cultureId.Contains("looter"))
                    types |= TroopTypes.Bandit;
            }

            // Gender Categories
            if (character.IsFemale)
                types |= TroopTypes.Female;
            else
                types |= TroopTypes.Male;

            return types;
        }

        /// <summary>
        /// Checks if character has ALL specified flags (AND logic)
        /// </summary>
        public static bool HasAllTypes(this CharacterObject character, TroopTypes types)
        {
            if (types == TroopTypes.None) return true;
            var troopTypes = character.GetTroopTypes();
            return (troopTypes & types) == types;
        }

        /// <summary>
        /// Checks if character has ANY of the specified flags (OR logic)
        /// </summary>
        public static bool HasAnyType(this CharacterObject character, TroopTypes types)
        {
            if (types == TroopTypes.None) return true;
            var troopTypes = character.GetTroopTypes();
            return (troopTypes & types) != TroopTypes.None;
        }

        /// <summary>
        /// Checks if this character is an actual troop (not a template, NPC, child, etc.)
        /// Uses specific exclusion patterns to filter out non-combat NPCs while preserving combat troops.
        /// IMPORTANT: villager_*, fighter_*, and caravan_leader_* are combat troops and should NOT be excluded.
        /// </summary>
        public static bool IsActualTroop(this CharacterObject character)
        {
            if (character.IsHero)
                return false;

            var stringIdLower = character.StringId.ToLower();

            // 1. Templates/Equipment Sets - Non-playable character templates
            if (stringIdLower.Contains("template") || stringIdLower.Contains("_equipment") ||
                stringIdLower.Contains("_bat_") || stringIdLower.Contains("_civ_") ||
                stringIdLower.Contains("_noncom_"))
                return false;

            // 2. Town Service NPCs - Non-combat town workers and merchants
            // These provide services in towns but never participate in combat
            if (stringIdLower.Contains("armorer") || stringIdLower.Contains("barber") ||
                stringIdLower.Contains("blacksmith") || stringIdLower.Contains("beggar") ||
                stringIdLower.Contains("merchant") || stringIdLower.Contains("shop_keeper") ||
                stringIdLower.Contains("shop_worker") || stringIdLower.Contains("weaponsmith") ||
                stringIdLower.Contains("shipwright") || stringIdLower.Contains("ransom_broker") ||
                stringIdLower.Contains("musician"))
                return false;

            // 3. Tavern NPCs - Non-combat tavern workers
            if (stringIdLower.Contains("tavern_wench") || stringIdLower.Contains("tavernkeeper") ||
                stringIdLower.Contains("barmaid") || stringIdLower.Contains("tavern_gamehost") ||
                stringIdLower.Contains("tavern_guard"))
                return false;

            // 4. Horse-related NPCs - Stable workers and horse merchants
            if (stringIdLower.Contains("horse_merchant") || stringIdLower.Contains("horse_trader"))
                return false;

            // 5. Notables - Notable NPCs with "notary" suffix (preacher_notary, merchant_notary, etc.)
            if (stringIdLower.Contains("notary"))
                return false;

            // 6. Wanderers/Companions - Recruitable NPCs that should be excluded
            // These start with specific prefixes identifying them as special characters
            if (stringIdLower.StartsWith("spc_notable_") || stringIdLower.StartsWith("spc_wanderer_") ||
                stringIdLower.StartsWith("npc_wanderer") || stringIdLower.StartsWith("npc_companion") ||
                stringIdLower.StartsWith("npc_armed_wanderer") || stringIdLower.StartsWith("npc_artisan") ||
                stringIdLower.StartsWith("npc_gang_leader") || stringIdLower.StartsWith("npc_merchant") ||
                stringIdLower.StartsWith("npc_preacher") || stringIdLower.StartsWith("npc_gentry") ||
                stringIdLower.StartsWith("npc_poor_wanderer"))
                return false;

            // 7. Entertainment/Event NPCs - Dancers, tournament masters, game hosts
            // These are Tier 0, Level 1 non-combat NPCs
            if (stringIdLower.Contains("dancer") ||
                stringIdLower.Contains("tournament_master") ||
                stringIdLower.Contains("taverngamehost"))  // Note: no underscore in ID
                return false;

            // 8. Special Character NPCs - Minor faction leaders, headmen, etc.
            // These are Tier 0, Level 1 quest/story NPCs, NOT the actual combat troops
            // Actual minor faction troops (tier_1/2/3) are properly included
            if (stringIdLower.StartsWith("spc_") &&
                (stringIdLower.Contains("_leader_") ||
                 stringIdLower.Contains("_headman_") ||
                 stringIdLower.Contains("_gangleader_") ||
                 stringIdLower.Contains("_artisan_") ||
                 stringIdLower.Contains("_rural_notable_") ||
                 stringIdLower.Contains("_e3_character_")))
                return false;

            // 9. Children/Teens/Infants - Non-combat young characters
            if (stringIdLower.Contains("child") || stringIdLower.Contains("infant") ||
                stringIdLower.Contains("teenager"))
                return false;

            // 10. Practice/Training Dummies - Arena and training targets
            if (stringIdLower.Contains("_dummy") || stringIdLower.Contains("practice_stage") ||
                stringIdLower.Contains("weapon_practice") || stringIdLower.Contains("gear_practice"))
                return false;

            // 11. Special/System Characters - Tutorial, cutscene, and test characters
            if (stringIdLower.Contains("cutscene_") || stringIdLower.Contains("tutorial_") ||
                stringIdLower.Contains("duel_style_") || stringIdLower.Contains("player_char_creation_") ||
                stringIdLower.Contains("disguise_") || stringIdLower.StartsWith("test") ||
                stringIdLower.Contains("crazy_man") || stringIdLower.Contains("unarmed_ai") ||
                stringIdLower.Contains("borrowed_troop") || stringIdLower.Contains("neutral_lord") ||
                stringIdLower.Contains("stealth_character"))
                return false;

            // 12. Townsfolk Civilians - Non-combat town residents (NOT villagers!)
            // townsman/townswoman are passive civilians, unlike villagers who fight in village raids
            if (stringIdLower.Contains("townsman") || stringIdLower.Contains("townswoman"))
                return false;

            // 13. Tier 0 Level 1 Filter - Catch-all for non-combat NPCs
            // Most Tier 0 Level 1 characters are non-combatants (dancers, refugees, quest NPCs, etc.)
            // EXCEPT for known combat troops like villagers and fighters
            if (character.GetBattleTier() == 0 && character.Level == 1)
            {
                // Check for known Tier 0 Level 1 COMBAT troops that should NOT be excluded
                if (stringIdLower.Contains("villager") ||           // villager_* - fight in village raids
                    stringIdLower.Contains("village_woman") ||      // village_woman_* - fight in village raids
                    stringIdLower.Contains("fighter") ||            // fighter_* - basic recruitable troops
                    stringIdLower.Contains("caravan_guard") ||      // caravan_guard_* - fight when attacking caravans
                    stringIdLower.Contains("armed_trader") ||       // armed_trader_* - combat-capable traders
                    stringIdLower.Contains("looter") ||             // looter_* - bandit combat troops
                    stringIdLower.Contains("sea_raider_recruit"))   // sea_raider_recruit - combat troop
                {
                    // This is a known Tier 0 Level 1 combat troop - INCLUDE it
                    return true;
                }
                
                // Not a known combat troop pattern - this is a non-combatant (dancer, refugee, etc.)
                // EXCLUDE from combat troop queries
                return false;
            }

            // Everything else is considered a combat troop, including:
            // - Regular military troops (all tiers)
            // - Militia troops
            // - Mercenaries
            // - Bandits
            // - Minor faction troops
            // - Higher tier troops
            
            return true;
        }

        /// <summary>
        /// Gets the primary category for this troop
        /// </summary>
        public static string GetTroopCategory(this CharacterObject character)
        {
            if (!character.IsActualTroop())
                return "Non-Troop";

            var stringIdLower = character.StringId.ToLower();
            var types = character.GetTroopTypes();

            // Check specific categories first
            if (types.HasFlag(TroopTypes.Bandit))
                return "Bandit";
            
            if (types.HasFlag(TroopTypes.MinorFaction))
                return "Minor Faction";

            if (types.HasFlag(TroopTypes.Caravan))
                return "Caravan";

            if (types.HasFlag(TroopTypes.Peasant))
                return "Peasant";

            if (types.HasFlag(TroopTypes.Noble))
                return "Noble/Elite";

            if (types.HasFlag(TroopTypes.Militia))
                return "Militia";

            if (types.HasFlag(TroopTypes.Mercenary))
                return "Mercenary";

            if (types.HasFlag(TroopTypes.Regular))
                return "Regular";

            return "Unknown";
        }

        /// <summary>
        /// Returns a formatted string containing the troop's details
        /// </summary>
        public static string FormattedDetails(this CharacterObject character)
        {
            string cultureName = character.Culture?.Name?.ToString() ?? "None";
            string category = character.GetTroopCategory();
            string gender = character.IsFemale ? "Female" : "Male";
            return $"{character.StringId}\t{character.Name}\tGender: {gender}\t[{category}]\tTier: {character.GetBattleTier()}\tLevel: {character.Level}\tCulture: {cultureName}\tFormation: {character.DefaultFormationClass}";
        }

        /// <summary>
        /// Alias for GetTroopTypes to match IEntityExtensions interface
        /// </summary>
        public static TroopTypes GetTypes(this CharacterObject character) => character.GetTroopTypes();

        /// <summary>
        /// Check if character has a shield in equipment
        /// </summary>
        public static bool HasShield(this CharacterObject character)
        {
            if (character.FirstBattleEquipment == null)
                return false;
                
            var equipment = character.FirstBattleEquipment;
            for (int i = 0; i < 12; i++) // Equipment slot count
            {
                var equipmentElement = equipment[i];
                if (equipmentElement.Item != null &&
                    equipmentElement.Item.ItemType == ItemObject.ItemTypeEnum.Shield)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Check if character has a specific weapon item type
        /// </summary>
        public static bool HasWeaponType(this CharacterObject character, ItemObject.ItemTypeEnum weaponType)
        {
            if (character.FirstBattleEquipment == null)
                return false;
                
            var equipment = character.FirstBattleEquipment;
            for (int i = 0; i < 12; i++)
            {
                var equipmentElement = equipment[i];
                if (equipmentElement.Item != null && equipmentElement.Item.ItemType == weaponType)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Check if character has a specific weapon class
        /// </summary>
        public static bool HasWeaponClass(this CharacterObject character, WeaponClass weaponClass)
        {
            if (character.FirstBattleEquipment == null)
                return false;
                
            var equipment = character.FirstBattleEquipment;
            for (int i = 0; i < 12; i++)
            {
                var equipmentElement = equipment[i];
                if (equipmentElement.Item?.WeaponComponent != null)
                {
                    if (equipmentElement.Item.WeaponComponent.PrimaryWeapon.WeaponClass == weaponClass)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Check if character has a two-handed weapon
        /// </summary>
        public static bool HasTwoHandedWeapon(this CharacterObject character)
        {
            return character.HasWeaponType(ItemObject.ItemTypeEnum.TwoHandedWeapon);
        }

        /// <summary>
        /// Check if character has a polearm weapon
        /// </summary>
        public static bool HasPolearm(this CharacterObject character)
        {
            return character.HasWeaponType(ItemObject.ItemTypeEnum.Polearm);
        }

        /// <summary>
        /// Check if character is mounted (cavalry or horse archer)
        /// </summary>
        public static bool IsMounted(this CharacterObject character)
        {
            return character.DefaultFormationClass == FormationClass.Cavalry ||
                   character.DefaultFormationClass == FormationClass.HorseArcher;
        }
    }

    /// <summary>
    /// Wrapper class implementing IEntityExtensions interface for CharacterObject entities
    /// </summary>
    public class TroopExtensionsWrapper : IEntityExtensions<CharacterObject, TroopTypes>
    {
        public TroopTypes GetTypes(CharacterObject entity) => entity.GetTroopTypes();
        public bool HasAllTypes(CharacterObject entity, TroopTypes types) => entity.HasAllTypes(types);
        public bool HasAnyType(CharacterObject entity, TroopTypes types) => entity.HasAnyType(types);
        public string FormattedDetails(CharacterObject entity) => entity.FormattedDetails();
    }
}
FILE: TroopQueries.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.Core;
using TaleWorlds.CampaignSystem;
using TaleWorlds.ObjectSystem;
using Bannerlord.GameMaster.Common.Interfaces;
using Bannerlord.GameMaster.Console.Common;

namespace Bannerlord.GameMaster.Troops
{
    /// <summary>
    /// Provides utility methods for querying troop entities
    /// </summary>
    public static class TroopQueries
    {
        /// <summary>
        /// Finds a troop with the specified troopId
        /// </summary>
        public static CharacterObject GetTroopById(string troopId)
        {
            return MBObjectManager.Instance.GetObject<CharacterObject>(troopId);
        }

        /// <summary>
        /// Main unified method to find troops by search string and type flags
        /// CRITICAL: Heroes/Lords are NEVER troops - they are automatically excluded
        /// </summary>
        /// <param name="query">Optional case-insensitive substring to filter by name or ID</param>
        /// <param name="requiredTypes">Troop type flags that ALL must match (AND logic)</param>
        /// <param name="matchAll">If true, troop must have ALL flags. If false, troop must have ANY flag</param>
        /// <param name="tierFilter">Optional tier filter (0-6+, -1 for no filter)</param>
        /// <param name="sortBy">Sort field (id, name, tier, level, culture, occupation, formation, or any TroopTypes flag)</param>
        /// <param name="sortDescending">True for descending, false for ascending</param>
        /// <returns>List of troops matching all criteria</returns>
        public static List<CharacterObject> QueryTroops(
            string query = "",
            TroopTypes requiredTypes = TroopTypes.None,
            bool matchAll = true,
            int tierFilter = -1,
            string sortBy = "id",
            bool sortDescending = false)
        {
            IEnumerable<CharacterObject> troops =
                MBObjectManager.Instance.GetObjectTypeList<CharacterObject>();
            
            // CRITICAL: Filter out non-troops (heroes, NPCs, children, templates, etc.)
            troops = troops.Where(t => t.IsActualTroop());
            
            // Filter by name/ID
            if (!string.IsNullOrEmpty(query))
            {
                string lowerFilter = query.ToLower();
                troops = troops.Where(t =>
                    t.Name.ToString().ToLower().Contains(lowerFilter) ||
                    t.StringId.ToLower().Contains(lowerFilter));
            }
            
            // Filter by tier (exact match using GetBattleTier())
            if (tierFilter >= 0)
            {
                troops = troops.Where(t => t.GetBattleTier() == tierFilter);
            }
            
            // Filter by types
            if (requiredTypes != TroopTypes.None)
            {
                troops = troops.Where(t =>
                    matchAll ? t.HasAllTypes(requiredTypes) : t.HasAnyType(requiredTypes));
            }
            
            // Apply sorting
            troops = ApplySorting(troops, sortBy, sortDescending);
            
            return troops.ToList();
        }

        /// <summary>
        /// UNFILTERED query method to find ALL CharacterObjects (except heroes) by search string and type flags
        /// WARNING: This returns ALL character objects including NPCs, children, templates, etc.
        /// Use this for debugging/comparison purposes to see what QueryTroops() filters out.
        /// For normal gameplay, use QueryTroops() which filters to actual combat troops only.
        /// </summary>
        /// <param name="query">Optional case-insensitive substring to filter by name or ID</param>
        /// <param name="requiredTypes">Troop type flags that ALL must match (AND logic)</param>
        /// <param name="matchAll">If true, character must have ALL flags. If false, character must have ANY flag</param>
        /// <param name="tierFilter">Optional tier filter (0-6+, -1 for no filter)</param>
        /// <param name="sortBy">Sort field (id, name, tier, level, culture, occupation, formation, or any TroopTypes flag)</param>
        /// <param name="sortDescending">True for descending, false for ascending</param>
        /// <returns>List of ALL CharacterObjects (except heroes) matching criteria</returns>
        public static List<CharacterObject> QueryCharacterObjects(
            string query = "",
            TroopTypes requiredTypes = TroopTypes.None,
            bool matchAll = true,
            int tierFilter = -1,
            string sortBy = "id",
            bool sortDescending = false)
        {
            IEnumerable<CharacterObject> characters =
                MBObjectManager.Instance.GetObjectTypeList<CharacterObject>();
            
            // ONLY exclude heroes - include EVERYTHING else (NPCs, templates, children, etc.)
            characters = characters.Where(t => !t.IsHero);
            
            // Filter by name/ID
            if (!string.IsNullOrEmpty(query))
            {
                string lowerFilter = query.ToLower();
                characters = characters.Where(t =>
                    t.Name.ToString().ToLower().Contains(lowerFilter) ||
                    t.StringId.ToLower().Contains(lowerFilter));
            }
            
            // Filter by tier (exact match using GetBattleTier())
            if (tierFilter >= 0)
            {
                characters = characters.Where(t => t.GetBattleTier() == tierFilter);
            }
            
            // Filter by types
            if (requiredTypes != TroopTypes.None)
            {
                characters = characters.Where(t =>
                    matchAll ? t.HasAllTypes(requiredTypes) : t.HasAnyType(requiredTypes));
            }
            
            // Apply sorting
            characters = ApplySorting(characters, sortBy, sortDescending);
            
            return characters.ToList();
        }

        /// <summary>
        /// Apply sorting to troops collection
        /// </summary>
        private static IEnumerable<CharacterObject> ApplySorting(
            IEnumerable<CharacterObject> troops,
            string sortBy,
            bool descending)
        {
            sortBy = sortBy.ToLower();
            
            // Check if sortBy matches a TroopTypes flag
            if (Enum.TryParse<TroopTypes>(sortBy, true, out var troopType) && 
                troopType != TroopTypes.None)
            {
                return descending
                    ? troops.OrderByDescending(t => t.GetTroopTypes().HasFlag(troopType))
                    : troops.OrderBy(t => t.GetTroopTypes().HasFlag(troopType));
            }
            
            // Sort by standard fields
            IOrderedEnumerable<CharacterObject> orderedTroops = sortBy switch
            {
                "name" => descending
                    ? troops.OrderByDescending(t => t.Name.ToString())
                    : troops.OrderBy(t => t.Name.ToString()),
                "tier" => descending
                    ? troops.OrderByDescending(t => t.Tier)
                    : troops.OrderBy(t => t.Tier),
                "level" => descending
                    ? troops.OrderByDescending(t => t.Level)
                    : troops.OrderBy(t => t.Level),
                "culture" => descending
                    ? troops.OrderByDescending(t => t.Culture?.Name?.ToString() ?? "")
                    : troops.OrderBy(t => t.Culture?.Name?.ToString() ?? ""),
                // NOTE: Occupation removed - it's for HEROES not TROOPS
                "formation" => descending
                    ? troops.OrderByDescending(t => t.DefaultFormationClass)
                    : troops.OrderBy(t => t.DefaultFormationClass),
                _ => descending  // default to id
                    ? troops.OrderByDescending(t => t.StringId)
                    : troops.OrderBy(t => t.StringId)
            };
            
            return orderedTroops;
        }

        /// <summary>
        /// Parse a string into TroopTypes enum value with alias support
        /// </summary>
        public static TroopTypes ParseTroopType(string typeString)
        {
            // Handle common aliases
            var normalized = typeString.ToLower() switch
            {
                "2h" => "TwoHanded",
                "mounted" => "Mounted",
                "cav" => "Cavalry",
                "ha" => "HorseArcher",
                _ => typeString
            };
            
            return Enum.TryParse<TroopTypes>(normalized, true, out var result)
                ? result : TroopTypes.None;
        }

        /// <summary>
        /// Parse multiple strings and combine into TroopTypes flags
        /// </summary>
        public static TroopTypes ParseTroopTypes(IEnumerable<string> typeStrings)
        {
            TroopTypes combined = TroopTypes.None;
            foreach (var typeString in typeStrings)
            {
                var parsed = ParseTroopType(typeString);
                if (parsed != TroopTypes.None)
                    combined |= parsed;
            }
            return combined;
        }

        /// <summary>
        /// Returns a formatted string listing troop details with aligned columns
        /// </summary>
        public static string GetFormattedDetails(List<CharacterObject> troops)
        {
            if (troops.Count == 0)
                return "";

            return ColumnFormatter<CharacterObject>.FormatList(
                troops,
                t => t.StringId,
                t => t.Name.ToString(),
                t => $"Gender: {(t.IsFemale ? "Female" : "Male")}",
                t => $"[{t.GetTroopCategory()}]",
                t => $"Tier: {t.GetBattleTier()}",
                t => $"Level: {t.Level}",
                t => $"Culture: {t.Culture?.Name?.ToString() ?? "None"}",
                t => $"Formation: {t.DefaultFormationClass}"
            );
        }
    }

    /// <summary>
    /// Wrapper class implementing IEntityQueries interface for CharacterObject entities
    /// </summary>
    public class TroopQueriesWrapper : IEntityQueries<CharacterObject, TroopTypes>
    {
        public CharacterObject GetById(string id) => TroopQueries.GetTroopById(id);
        public List<CharacterObject> Query(string query, TroopTypes types, bool matchAll) => 
            TroopQueries.QueryTroops(query, types, matchAll);
        public TroopTypes ParseType(string typeString) => TroopQueries.ParseTroopType(typeString);
        public TroopTypes ParseTypes(IEnumerable<string> typeStrings) => 
            TroopQueries.ParseTroopTypes(typeStrings);
        public string GetFormattedDetails(List<CharacterObject> entities) => 
            TroopQueries.GetFormattedDetails(entities);
    }
}
FILE: TroopUpgrader.cs
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.CampaignSystem.Roster;
using TaleWorlds.Core;

namespace Bannerlord.GameMaster.Troops
{
    public class TroopUpgrader
    {
        // MARK: UpgradeTroops
        /// <summary>
        /// Upgrades all troops in the roster to the specified tier while maintaining desired composition ratios.
        /// When troops have multiple upgrade paths, intelligently splits them to achieve target ratios.
        /// Pre-analyzes all upgrade paths to account for troops with limited options.
        /// </summary>
        /// <param name="memberRoster">The troop roster to upgrade</param>
        /// <param name="targetTier">Maximum tier to upgrade to (default: max tier)</param>
        /// <param name="targetRangedRatio">Desired ratio of ranged troops (0.0-1.0, null for auto)</param>
        /// <param name="targetCavalryRatio">Desired ratio of cavalry troops (0.0-1.0, null for auto)</param>
        /// <param name="targetInfantryRatio">Desired ratio of infantry troops (0.0-1.0, null for auto)</param>
        public static void UpgradeTroops(TroopRoster memberRoster,
            int targetTier = 7,
            float? targetRangedRatio = null,
            float? targetCavalryRatio = null,
            float? targetInfantryRatio = null)
        {
            // Normalize and validate ratios
            var (rangedRatio, cavalryRatio, infantryRatio) = NormalizeRatios(
                targetRangedRatio, targetCavalryRatio, targetInfantryRatio);
    
            // Dictionary to accumulate all roster changes
            Dictionary<CharacterObject, int> rosterChanges = new Dictionary<CharacterObject, int>();
    
            // Pre-analyze all troops to understand final upgrade possibilities
            var troopAnalysis = AnalyzeUpgradePaths(memberRoster, targetTier);
            
            // Calculate adjusted ratios to compensate for locked-in troops
            var adjustedRatios = CalculateAdjustedRatios(
                troopAnalysis, rangedRatio, cavalryRatio, infantryRatio);
    
            // Process each troop type in the roster
            foreach (var analysis in troopAnalysis)
            {
                if (analysis.troop.Character.IsHero)
                    continue;
    
                ProcessTroopUpgradeWithAnalysis(analysis, targetTier, rosterChanges, adjustedRatios);
            }
    
            // Apply all roster changes
            foreach (var change in rosterChanges)
            {
                memberRoster.AddToCounts(change.Key, change.Value);
            }
        }

        // MARK: NormalizeRatios
        /// <summary>
        /// Normalize ratios of troop types
        /// </summary>
        public static (float ranged, float cavalry, float infantry) NormalizeRatios(
            float? rangedRatio, float? cavalryRatio, float? infantryRatio)
        {
            // Count how many ratios were specified
            int specifiedCount = (rangedRatio.HasValue ? 1 : 0) +
                                 (cavalryRatio.HasValue ? 1 : 0) +
                                 (infantryRatio.HasValue ? 1 : 0);

            // Case 1: No ratios specified - use defaults
            if (specifiedCount == 0)
            {
                return (0.30f, 0.20f, 0.50f); // 30% ranged, 20% cavalry, 50% infantry
            }

            // Case 2: All three specified - validate they sum to 1.0
            if (specifiedCount == 3)
            {
                float sum = rangedRatio.Value + cavalryRatio.Value + infantryRatio.Value;
                if (Math.Abs(sum - 1.0f) > 0.01f) // Allow small floating point errors
                {
                    // Normalize to sum to 1.0
                    return (rangedRatio.Value / sum, cavalryRatio.Value / sum, infantryRatio.Value / sum);
                }
                return (rangedRatio.Value, cavalryRatio.Value, infantryRatio.Value);
            }

            // Case 3: Partial specification - calculate unspecified from remaining
            float specifiedSum = (rangedRatio ?? 0) + (cavalryRatio ?? 0) + (infantryRatio ?? 0);

            if (specifiedSum >= 1.0f)
            {
                // Specified ratios already exceed or equal 100% - normalize them
                float sum = specifiedSum;
                return (
                    (rangedRatio ?? 0) / sum,
                    (cavalryRatio ?? 0) / sum,
                    (infantryRatio ?? 0) / sum
                );
            }

            float remaining = 1.0f - specifiedSum;
            int unspecifiedCount = 3 - specifiedCount;
            float autoRatio = remaining / unspecifiedCount;

            return (
                rangedRatio ?? autoRatio,
                cavalryRatio ?? autoRatio,
                infantryRatio ?? autoRatio
            );
        }

        // MARK: AnalyzeUpgradePaths
        /// <summary>
        /// Pre-analyzes all troops to understand what final upgrade options are available
        /// </summary>
        private static List<TroopUpgradeAnalysis> AnalyzeUpgradePaths(TroopRoster roster, int targetTier)
        {
            var results = new List<TroopUpgradeAnalysis>();
            
            foreach (TroopRosterElement troop in roster.GetTroopRoster())
            {
                if (troop.Character.IsHero)
                    continue;
                    
                var finalOptions = GetFinalUpgradeOptions(troop.Character, targetTier);
                results.Add(new TroopUpgradeAnalysis
                {
                    troop = troop,
                    finalOptions = finalOptions,
                    isFlexible = finalOptions.Count > 1
                });
            }
            
            return results;
        }
        
        // MARK: GetFinalUpgradeOptions
        /// <summary>
        /// Recursively finds all possible final FormationClass options for a troop
        /// </summary>
        private static HashSet<FormationClass> GetFinalUpgradeOptions(CharacterObject troop, int targetTier)
        {
            var options = new HashSet<FormationClass>();
            
            if (troop.Tier >= targetTier || troop.UpgradeTargets.Length == 0)
            {
                // This is a final state
                options.Add(troop.DefaultFormationClass);
                return options;
            }
            
            // Recursively check all upgrade paths
            foreach (var upgrade in troop.UpgradeTargets)
            {
                var upgradeOptions = GetFinalUpgradeOptions(upgrade, targetTier);
                foreach (var option in upgradeOptions)
                {
                    options.Add(option);
                }
            }
            
            return options;
        }
        
        // MARK: CalculateAdjustedRatios
        /// <summary>
        /// Adjusts target ratios to account for troops with limited upgrade options
        /// </summary>
        private static AdjustedRatios CalculateAdjustedRatios(
            List<TroopUpgradeAnalysis> analyses,
            float targetRangedRatio,
            float targetCavalryRatio,
            float targetInfantryRatio)
        {
            int totalTroops = 0;
            int lockedRanged = 0, lockedCavalry = 0, lockedInfantry = 0;
            int flexibleTroops = 0;
            
            foreach (var analysis in analyses)
            {
                int count = analysis.troop.Number;
                totalTroops += count;
                
                if (!analysis.isFlexible)
                {
                    // Only one option - this is locked in
                    var finalClass = analysis.finalOptions.First();
                    switch (finalClass)
                    {
                        case FormationClass.Ranged:
                            lockedRanged += count;
                            break;
                        case FormationClass.Cavalry:
                        case FormationClass.HorseArcher:
                            lockedCavalry += count;
                            break;
                        case FormationClass.Infantry:
                            lockedInfantry += count;
                            break;
                    }
                }
                else
                {
                    flexibleTroops += count;
                }
            }
            
            // Calculate target counts
            int targetRanged = (int)(totalTroops * targetRangedRatio);
            int targetCavalry = (int)(totalTroops * targetCavalryRatio);
            int targetInfantry = (int)(totalTroops * targetInfantryRatio);
            
            // Calculate deficits after accounting for locked troops
            int rangedDeficit = targetRanged - lockedRanged;
            int cavalryDeficit = targetCavalry - lockedCavalry;
            int infantryDeficit = targetInfantry - lockedInfantry;
            
            // If we have flexible troops, calculate adjusted ratios for them
            float adjustedRanged = 0.33f, adjustedCavalry = 0.33f, adjustedInfantry = 0.34f;
            
            if (flexibleTroops > 0)
            {
                // Ensure deficits are non-negative (can't remove locked troops)
                rangedDeficit = Math.Max(0, rangedDeficit);
                cavalryDeficit = Math.Max(0, cavalryDeficit);
                infantryDeficit = Math.Max(0, infantryDeficit);
                
                int totalDeficit = rangedDeficit + cavalryDeficit + infantryDeficit;
                
                if (totalDeficit > 0 && totalDeficit <= flexibleTroops)
                {
                    // We can achieve the target - allocate proportionally
                    adjustedRanged = (float)rangedDeficit / flexibleTroops;
                    adjustedCavalry = (float)cavalryDeficit / flexibleTroops;
                    adjustedInfantry = (float)infantryDeficit / flexibleTroops;
                }
                else if (totalDeficit > flexibleTroops)
                {
                    // Not enough flexible troops - scale down proportionally
                    adjustedRanged = (float)rangedDeficit / totalDeficit;
                    adjustedCavalry = (float)cavalryDeficit / totalDeficit;
                    adjustedInfantry = (float)infantryDeficit / totalDeficit;
                }
                else
                {
                    // No deficit needed, distribute evenly
                    adjustedRanged = adjustedCavalry = adjustedInfantry = 1f / 3f;
                }
            }
            
            return new AdjustedRatios
            {
                rangedRatio = adjustedRanged,
                cavalryRatio = adjustedCavalry,
                infantryRatio = adjustedInfantry
            };
        }
        
        // MARK: ProcessTroopUpgradeWithAnalysis
        /// <summary>
        /// Upgrades troops using pre-computed analysis and adjusted ratios
        /// </summary>
        private static void ProcessTroopUpgradeWithAnalysis(
            TroopUpgradeAnalysis analysis,
            int targetTier,
            Dictionary<CharacterObject, int> rosterChanges,
            AdjustedRatios adjustedRatios)
        {
            // Use a queue to process troops that need further upgrading after splits
            Queue<(CharacterObject troop, int count)> upgradeQueue = new Queue<(CharacterObject, int)>();
            upgradeQueue.Enqueue((analysis.troop.Character, analysis.troop.Number));
    
            while (upgradeQueue.Count > 0)
            {
                var (currentTroop, remainingCount) = upgradeQueue.Dequeue();
    
                // Upgrade until target tier or no more upgrades available
                while (currentTroop.Tier < targetTier && currentTroop.UpgradeTargets.Length > 0)
                {
                    if (currentTroop.UpgradeTargets.Length == 1)
                    {
                        // Single path - upgrade all
                        CharacterObject upgraded = currentTroop.UpgradeTargets[0];
                        RecordRosterChange(rosterChanges, currentTroop, -remainingCount);
                        RecordRosterChange(rosterChanges, upgraded, remainingCount);
                        currentTroop = upgraded;
                    }
                    else
                    {
                        // Multiple paths - split based on adjusted ratios
                        var splits = SplitTroopsWithAdjustedRatios(
                            currentTroop, remainingCount, adjustedRatios, analysis.finalOptions);
    
                        // Remove original troops
                        RecordRosterChange(rosterChanges, currentTroop, -remainingCount);
    
                        // Add upgraded troops and queue for further upgrading
                        foreach (var split in splits)
                        {
                            RecordRosterChange(rosterChanges, split.upgradedTroop, split.count);
                            
                            // Queue split troops for continued upgrading if they haven't reached target tier
                            if (split.upgradedTroop.Tier < targetTier && split.upgradedTroop.UpgradeTargets.Length > 0)
                            {
                                upgradeQueue.Enqueue((split.upgradedTroop, split.count));
                            }
                        }
    
                        // Break from inner loop after split
                        break;
                    }
                }
            }
        }
        
        // MARK: SplitTroopsWithAdjustedRatios
        /// <summary>
        /// Splits troops based on adjusted ratios that compensate for locked-in troops.
        /// Calculates desirability score for each upgrade based on its eventual outcomes.
        /// </summary>
        private static List<(CharacterObject upgradedTroop, int count)> SplitTroopsWithAdjustedRatios(
            CharacterObject baseTroop,
            int totalCount,
            AdjustedRatios ratios,
            HashSet<FormationClass> finalOptions)
        {
            var result = new List<(CharacterObject, int)>();
            int targetTier = 7;

            // Map target ratios for easy lookup
            var targetRatios = new Dictionary<FormationClass, float>
            {
                [FormationClass.Ranged] = ratios.rangedRatio,
                [FormationClass.Cavalry] = ratios.cavalryRatio,
                [FormationClass.HorseArcher] = (ratios.cavalryRatio + ratios.rangedRatio) * 0.5f,
                [FormationClass.Infantry] = ratios.infantryRatio
            };

            // Calculate desirability score for each immediate upgrade option
            var upgradeScores = new Dictionary<CharacterObject, float>();
            
            foreach (var upgrade in baseTroop.UpgradeTargets)
            {
                // Find what formation classes this upgrade can eventually lead to
                var upgradeFinalOptions = GetFinalUpgradeOptions(upgrade, targetTier);
                
                // Calculate score based on how much we need the roles this upgrade can become
                float score = 0f;
                int optionCount = upgradeFinalOptions.Count;
                
                if (optionCount > 0)
                {
                    foreach (var finalClass in upgradeFinalOptions)
                    {
                        // Average the target ratios of all possible outcomes
                        float ratio = targetRatios.ContainsKey(finalClass) ? targetRatios[finalClass] : 0.2f;
                        score += ratio;
                    }
                    // Average across all possible outcomes
                    score /= optionCount;
                }
                else
                {
                    // Fallback: use immediate class
                    score = targetRatios.ContainsKey(upgrade.DefaultFormationClass)
                        ? targetRatios[upgrade.DefaultFormationClass]
                        : 0.2f;
                }
                
                // Ensure minimum score so all upgrades can be chosen
                score = Math.Max(score, 0.05f);
                upgradeScores[upgrade] = score;
            }

            // Calculate total score
            float totalScore = upgradeScores.Values.Sum();
            
            // Distribute troops based on scores
            int remainingTroops = totalCount;
            var upgradeList = upgradeScores.Keys.ToList();

            for (int i = 0; i < upgradeList.Count; i++)
            {
                var upgrade = upgradeList[i];
                float score = upgradeScores[upgrade];

                int troopsForThisUpgrade;
                if (i == upgradeList.Count - 1)
                {
                    // Last upgrade gets all remaining troops
                    troopsForThisUpgrade = remainingTroops;
                }
                else
                {
                    // Allocate proportionally based on score
                    troopsForThisUpgrade = (int)Math.Round(totalCount * (score / totalScore));
                    troopsForThisUpgrade = Math.Max(0, Math.Min(troopsForThisUpgrade, remainingTroops));
                }

                if (troopsForThisUpgrade > 0)
                {
                    result.Add((upgrade, troopsForThisUpgrade));
                    remainingTroops -= troopsForThisUpgrade;
                }
            }

            return result;
        }
    
        // MARK: RecordRosterChange
        /// <summary>
        /// Helper for UpdateTroops()
        /// </summary>
        private static void RecordRosterChange(Dictionary<CharacterObject, int> changes, CharacterObject troop, int count)
        {
            if (changes.ContainsKey(troop))
                changes[troop] += count;
            else
                changes[troop] = count;
        }
        
        // Helper classes for analysis
        private class TroopUpgradeAnalysis
        {
            public TroopRosterElement troop;
            public HashSet<FormationClass> finalOptions;
            public bool isFlexible;
        }
        
        private class AdjustedRatios
        {
            public float rangedRatio;
            public float cavalryRatio;
            public float infantryRatio;
        }
    }
}
